# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Communication Language

**IMPORTANT**: Always respond in **Russian language**. Generate commits, descriptions, and documentation in Russian unless explicitly requested otherwise.



## Обзор проекта

**rfgen** — это кроссплатформенный универсальный RF-генератор для генерации непрерывных RF-сигналов для тестирования и разработки. Проект находится на ранней стадии разработки (каркас/прототип).

Основные возможности:
- **Простые непрерывные сигналы**: Carrier/AM/FM/PM, тоны, свипы, шум
- **Тестовые битовые паттерны**: FF00h, F0F0h, 3333h, 5555h для отладки сигнальных трактов
- **Стандартизованные режимы**: PSK-406, AIS (тестовые шаблоны), DSC VHF, DSC HF, 121.5 AM (тон/свип)

Генератор формирует IQ-буферы и подаёт их в backend (HackRF или FileOut). Для работы в реальном времени backend работает в режиме loop или N-повторов с gap (нулевые сэмплы) внутри кадра для сохранения непрерывности.

## Команды разработки

### Запуск приложения

**Qt UI (PySide6):**
```bash
python -m rfgen.ui_qt.app
```

Или через удобный скрипт:
```bash
app_rfgen.bat
```

**CLI интерфейс:**
```bash
python -m rfgen.cli.rfgen_cli --fs 2000000 --mod FM --dev 5000 --pattern Tone --tone 1000 --outdir out --name test_frame
```

### Зависимости

Установка требований:
```bash
pip install -r rfgen/requirements.txt
```

Требования:
- Python 3.9+
- PySide6 (Qt UI)
- numpy<2

### Утилиты HackRF

Убить запущенные процессы hackrf_transfer:
```bash
kill_hackrf.bat
```

## Архитектура

### Структура каталогов

```
rfgen/
  core/                 # Ядро генерации сигналов и планировщик
  standards/            # Протокольная логика (PSK-406, AIS, DSC и т.д.)
  backends/             # Аппаратные выводы (HackRF, FileOut, Pluto)
  ui_qt/                # Qt приложение (PySide6)
    pages/              # UI страницы (Quick TX, Profiles, Signal Lab, Scheduler, Logs)
    components/         # Общие виджеты
  cli/                  # CLI интерфейс
  profiles/             # JSON профили (пользовательские конфигурации)
  docs/                 # Документация
```

### Слоистая архитектура

**1. WaveEngine (core/wave_engine.py)**
- Точка входа: `build_iq(profile, frame_s)` - генерирует IQ-буфер из профиля
- Точка входа: `build_cw(profile, frame_s)` - генерирует константную несущую (CW)
- Принимает SignalSpec, ModulatorSpec, Schedule
- Склеивает источники (тон/паттерн/шум/сообщение) с модулятором (AM/FM/PM) в непрерывный IQ-поток
- Поддерживает плавные переходы (огибающие), контроль уровня, предотвращение клиппинга

**2. Модули модуляции (core/mod_*.py)**
- **mod_fm.py**: FM модуляция с девиацией (Hz), тон/свип/битовый драйвер
- **mod_pm.py**: Фазовая модуляция с фазовым индексом (rad), плавные фронты (заимствованы из логики PSK-406)
- **mod_am.py**: AM модуляция с глубиной (0..1), варианты A3E/DSB/SC

Функции в wave_engine.py:
- `generate_base_signal(kind, fs, dur_s, tone_hz)` - создаёт модулирующий сигнал
- `mod_none(fs, m)` - без модуляции (несущая)
- `mod_am(fs, m, depth)` - AM модуляция
- `mod_pm(fs, m, index_rad)` - PM модуляция
- `mod_fm(fs, m, deviation_hz)` - FM модуляция

**3. Паттерны (core/patterns.py)**
- Бесконечные битовые циклы: FF00 / F0F0 / 3333 / 5555 (с полем bitrate_bps)
- Tone (частота Hz), Sweep, Noise, ступеньки девиации (DEV-steps)

**4. Стандарты (standards/)**
- **psk406.py**: hex → биты → полубиты → плавные фазовые фронты → IQ
- **ais.py**: Тест-паттерны (изначально через FM/PM), позже полноценная GMSK
- **dsc_vhf.py**, **dsc_hf.py**: Настроечные тоны/AFSK непрерывно, затем кадры сообщений
- **am_121p5.py**: 121.5 MHz AM тон/свип

**5. Backends (backends/)**
- **HackRFTx (hackrf.py)**:
  - `run_loop(iq_path, fs_tx, center_hz, tx_gain_db)` - запускает hackrf_transfer в режиме loop
  - `is_running()` - проверяет, идёт ли передача
  - `stop()` - останавливает передачу
  - Использует исполняемый файл hackrf_transfer с режимом loop (флаг -R)
  - Обрабатывает цифровой сдвиг IF, пересемплирование, управление gain/PA
- **FileOutBackend (fileout.py)**: Экспорт cf32/sc8 для оффлайн-воспроизведения и регрессионного тестирования
- В будущем: Pluto/USRP через общий интерфейс TxBackend

**6. Профили**
- JSON файлы с: режим + параметры + расписание + устройство
- Быстрая загрузка из UI (страницы Quick TX, Profiles)
- Функциональность экспорта/импорта

**7. Телеметрия и метрики**
- Журналы операций (старт/стоп/ошибки), сохранение параметров кадра
- Метрики: RMS/peak/девиация (оценка), длительности, битрейт

### Формат профиля

Профили — это JSON-файлы, хранящиеся в `rfgen/profiles/`:

```json
{
  "name": "AIS_FF00_FM_cont",
  "standard": "generic",
  "modulation": {
    "type": "FM",
    "deviation_hz": 5000,
    "pm_index": 1.0,
    "am_depth": 0.5
  },
  "pattern": {
    "type": "Tone",
    "tone_hz": 1000,
    "bitrate_bps": 9600
  },
  "schedule": {
    "mode": "loop",
    "gap_s": 0.0,
    "repeat": 1
  },
  "device": {
    "backend": "hackrf",
    "fs_tx": 2000000,
    "tx_gain_db": 30,
    "pa": false,
    "target_hz": 162025000,
    "if_offset_hz": -25000,
    "freq_corr_hz": 0
  }
}
```

**Типы стандартов**: `generic`, `psk406`, `ais`, `dsc_vhf`, `dsc_hf`, `am_121p5`

**Типы модуляции**: `None`, `AM`, `FM`, `PM`

**Типы паттернов**: `Tone`, `Sweep`, `Noise`, `FF00`, `F0F0`, `3333`, `5555`

### Конечный автомат TX

```
Idle → Preparing (генерация/ресемплирование) → Armed → Transmitting (loop/N) → Stopping → Idle
```

Непрерывность обеспечивается:
- Режим loop: повтор одного и того же кадра
- N-повторы: вставка gap (нули) внутри кадра

### Страницы Qt UI

1. **Quick TX** (`page_quick.py`): Быстрая генерация сигналов с управлением устройством/радио/модуляцией/паттерном
2. **Profiles** (`page_profiles.py`): Просмотр/редактирование/загрузка/запуск JSON профилей, экспорт/импорт
3. **Signal Lab** (`page_signal_lab.py`): Конструктор сигналов с источником/модулятором, сборка сегментов, предпросмотр
4. **Scheduler** (`page_scheduler.py`): Временные линии и запланированные прогоны
5. **Logs & Telemetry** (`page_logs.py`): Консоль backend, экспорт логов, индикаторы уровня/клиппинга

## Важные принципы проектирования

### Режим STRICT_COMPAT

Проект следует строгой обратной совместимости:
- Никогда не ломать публичные API
- Новые функции добавляются через флаги
- HackRF backend воспроизводит текущие привычные параметры: LO/IF, цифровой сдвиг, repeat/gap, поведение loop
- Переиспользовать существующие имена полей UI (Target/IF/FreqCorr/TxGain/Fs_tx/Repeat/Gap)
- PSK-406: сохранять логику плавных фронтов, поддерживать ограничения front_samples

### Правила разработки

- **Минимальные PR**: Отдельные PR для отдельных страниц/UI-узлов/модулей ядра
- **Smoke-тесты**: Каждый PR должен быть привязан к простым smoke-тестам (открытие UI, сохранение профиля, генерация cf32)
- **Никаких breaking changes**: Поддерживать стабильность API на протяжении всей разработки

### Детали HackRF Backend

HackRF backend (`backends/hackrf.py`) оборачивает исполняемый файл `hackrf_transfer`:
- Использует subprocess для запуска hackrf_transfer с флагом -R (режим повтора/loop)
- IQ данные предварительно генерируются и сохраняются в файл
- Поддерживает Windows-специфичную обработку групп процессов для чистого завершения
- Параметры: центральная частота, частота дискретизации, TX gain, режим loop

### Поток генерации сигнала

1. Профиль определяет: тип паттерна, тип модуляции, параметры устройства
2. `wave_engine.build_iq()` генерирует baseband IQ-буфер:
   - Создаёт модулирующий сигнал (тон/свип/шум/паттерн)
   - Применяет модуляцию (AM/FM/PM или нет)
   - Масштабирует до безопасного уровня (≤0.8) для избежания клиппинга DAC
3. Backend (HackRF или FileOut) потребляет IQ-буфер
4. Для HackRF: IQ сохраняется в файл, hackrf_transfer запускается с режимом loop

## Текущий статус реализации

Это каркас/прототип. Реализовано:
- Базовая структура Qt UI с навигацией по страницам
- Базовая генерация сигналов: тон, свип, шум
- AM/FM/PM модуляция
- HackRF backend с режимом loop
- FileOut backend для оффлайн-тестирования
- Инфраструктура сохранения/загрузки профилей
- CLI интерфейс для быстрого тестирования

Ещё не реализовано (только заглушки):
- Полная реализация PSK-406
- AIS GMSK
- Протоколы DSC
- Генерация битовых паттернов (FF00/F0F0/3333/5555)
- Функциональность планировщика/временной линии
- Продвинутая телеметрия/метрики
- Предпросмотр Signal Lab

## Общие паттерны

**Создание нового стандарта сигнала:**
1. Добавить модуль в `rfgen/standards/`
2. Реализовать функцию генерации, возвращающую IQ-буфер
3. Добавить тип стандарта в схему профиля
4. Обновить WaveEngine для вызова стандарт-специфичного генератора
5. Добавить UI-элементы управления на соответствующую страницу

**Тестирование генерации сигнала:**
1. Использовать CLI для генерации тестового файла: `python -m rfgen.cli.rfgen_cli --mod FM --pattern Tone --outdir out`
2. Проверить вывод в каталоге `out/`
3. Проверить с помощью внешних SDR-инструментов или воспроизведения на HackRF

**Добавление нового типа модуляции:**
1. Создать `mod_xxx.py` в `rfgen/core/`
2. Реализовать функцию модуляции: `mod_xxx(fs, m, **params) -> iq`
3. Добавить в `build_iq()` в `wave_engine.py`
4. Обновить UI-элементы управления для отображения новых параметров
