### ТЗ, чтобы в интерфейсе задавать **паузу между кадрами** и **количество сообщений**. Опираться будем на текущую страницу `Page406` (есть `frame_count`, но нет управления паузой/loop). 

# Цель

Дать пользователю в UI управлять расписанием передачи 406-кадров:

* Режим: **Loop бесконечно** или **N кадров и стоп**
* **Пауза между кадрами** (в секундах или миллисекундах)

# Изменения в UI (`page_406.py`)

1. В группе **Transmission Settings**:

   * Добавить радиокнопки:

     * `Loop (endless)`
     * `Finite (N frames)`
   * Уже существующий `frame_count` показывать/активировать **только** при выборе `Finite`.
   * Добавить поле:

     * `Gap between frames:` `QDoubleSpinBox gap_s` (диапазон 0.0 … 60.0 сек, шаг 0.1, дефолт 8 сек)
   * Сохранение в профиль:

     * `profile["schedule"] = {"mode": "loop"|"repeat", "gap_s": float, "repeat": int}`
       (сейчас структура уже есть, но значения зашиты — сделать двустороннее связывание формы ↔ профиль).
   * Автосейв: подключить `gap_s.valueChanged` и переключатель режима к `_autosave_to_default()`.

2. При загрузке профиля:

   * Если `schedule.mode == "loop"` → активировать `Loop (endless)`, скрыть/задизейблить `frame_count`.
   * Если `schedule.mode == "repeat"` → активировать `Finite`, показать `frame_count = schedule.repeat`.
   * `gap_s` выставлять из `schedule.gap_s`.

3. При сборе профиля (`_collect_profile()`):

   * Читать текущее состояние радиокнопок и писать `mode`, `gap_s`, `repeat` в `profile["schedule"]`.

4. Кнопка **Generate** (fileout):

   * При `mode="loop"` — просто генерировать **один** кадр (как сейчас), `gap_s` можно игнорировать при сохранении cf32.
   * При `mode="repeat"` — сохранить **один** кадр (без конкатенации); конкатенацию пусть делает бэкенд при TX (см. ниже).

# Изменения в генерации/бэкенде

> NB: В генераторе 406 у нас уже есть pre/carrier/msg/post — пауза между кадрами **не должна** хардкодиться туда для finite-режима; для loop-режима она может быть встроенной (как сейчас), но управляться `gap_s` тоже удобно.

1. `standards.psk406.generate_psk406(prof)`

   * Добавить чтение `schedule.gap_s` и **два режима**:

     * Если `profile["schedule"]["mode"] == "loop"`: гарантировать, что **внутри одного кадра** есть «посттишина» равная `gap_s` (перезапишем `post_silence_ms = gap_s * 1000`).
       — Это обеспечит нужную паузу между повторами при `-R`.
     * Если `mode == "repeat"`: оставить post-тишину как раньше (не навязывать gap), т.к. паузу создаст бэкенд.

2. `backends.hackrf.HackRFTx.run_loop(...)`

   * Расширить сигнатуру: `run_loop(iq_path, fs_tx, center_hz, tx_gain_db, pa_enabled, mode: str, repeat: int, gap_s: float)`
   * Внутри:

     * **Если `mode == "loop"`**: как сейчас — один sc8-файл, запуск `hackrf_transfer` с `-R` (loop).
       — Здесь пауза обеспечивается «посттишиной» внутри файла (см. п.1).
     * **Если `mode == "repeat"`**: без `-R`. Сформировать **временный sc8**:

       ```
       temp = concat( [frame_sc8, zeros(gap_s * fs_tx * 2)] * repeat )
       ```

       и отдать его в `hackrf_transfer` **один раз**. После завершения процесс сам остановится.
     * Флаг `-a` выставлять по `pa_enabled` как сейчас.
     * Логировать в CMD строке `mode`, `repeat`, `gap_s`, а также **длину** конечного sc8 в сэмплах.

3. `page_406._start_hackrf(self, prof)`

   * Прокинуть в `run_loop(...)` значения:

     * `mode = prof["schedule"]["mode"]`
     * `repeat = prof["schedule"]["repeat"]`
     * `gap_s = prof["schedule"]["gap_s"]`
   * Текст статуса:

     * Loop: `Transmitting (loop) on XXX MHz, gap=Y.s`
     * Finite: `Transmitting N frames on XXX MHz, gap=Y.s`

# Значения по умолчанию

* `schedule.mode = "loop"` (как сейчас фактически работает)
* `schedule.gap_s = 8.0`
* `schedule.repeat = 5`
* При переключении режима UI пусть автоматически подставляет разумные дефолты (напр. при Finite — `repeat=5`).

# Валидация/ограничения

* `gap_s >= 0.0` (предупреждать если `< 0.01` — слишком короткая пауза может привести к «склейке» на анализаторе).
* `repeat` в диапазоне 1…10_000 (число кадров, защитить от случайно огромных значений).
* При `mode="repeat"` и очень больших файлах предупреждать о размере (например, > 200 МБ).

# Логи (для отладки)

* В UI-лог: строка CMD, `mode`, `repeat`, `gap_s`, итоговый размер sc8 в байтах/сэмплах.
* При `mode="repeat"` — вывести рассчитанную длительность передачи: `T ≈ repeat * (T_frame + gap_s)`.

# Приёмочные тесты

1. **Loop + gap**: `gap_s=0.5`, `mode=loop` → на спектре между повторами видим ~0.5 s тишины. Остановка по кнопке **Stop**.
2. **Finite, N=3**: `mode=repeat`, `repeat=3`, `gap_s=0.2` → передаётся ровно три кадра с паузами ~0.2 s, процесс завершается, UI пишет `Stopped`.
3. **Zero gap**: `gap_s=0.0` в loop → кадры следуют «встык»; в finite — конкатенация без нулей (только посттишина кадра).
4. **Autosave**: переключения режима/значений сохраняются в `default.json`; перезапуск приложения восстанавливает UI-состояние.

