### делаем **HF “как VHF”**: тот же API/поток (Hex/Builder → 10-бит DSC → AFSK 1300/2100 @ 1200Bd → FM → pre/carrier/post), только в файле `dsc_hf.py`. 

## Что уже есть

* VHF-генератор с нормальным **Builder → 10-бит → HEX → AFSK→FM** пайплайном и удобными хелперами (`build_primary_symbols_from_cfg`, `build_dsc_bits`, `build_dsc_vhf`). Это готовая эталонная логика. 
* В HF-файле уже есть “заглушка” **VHF-style** (`generate_dsc_hf_afsk_vhfstyle`), но `build_dsc_hf` сейчас ведёт в «HF-точный» F1B/J2B на 100 бод (и с MVP-плейсхолдером HEX). Нам нужно, чтобы **по умолчанию** HF шёл тем же путём, что VHF. 

---

## Короткий план правок

### 1) Включить «VHF-style» по умолчанию в `build_dsc_hf`

В `dsc_hf.py` заставим `build_dsc_hf` собирать payload как у VHF и вызывать `generate_dsc_hf_afsk_vhfstyle` (1200 бод, 1300/2100, FM, те же pre/post/carrier):

```diff
--- a/dsc_hf.py
+++ b/dsc_hf.py
@@
-def build_dsc_hf(profile: dict) -> np.ndarray:
-    """
-    Обёртка для генерации DSC HF IQ-буфера из профиля.
-    ...
-    """
-    sp = profile.get("standard_params", {})
-    input_mode = sp.get("input_mode", "hex")
-
-    # Определяем hex_message в зависимости от режима
-    if input_mode == "hex":
-        hex_message = sp.get("hex_message", "D5AA55D5AA55")
-    elif input_mode == "builder":
-        # MVP: генерируем тестовый payload
-        ...
-        hex_message = "D5AA55D5AA55"  # Placeholder
-        ...
-    else:
-        raise ValueError(f"Неизвестный input_mode: {input_mode}")
-
-    # Подготавливаем параметры для генератора
-    params = {
-        "device": profile.get("device", {}),
-        "standard_params": {
-            "hex_message": hex_message,
-            "symbol_rate": sp.get("symbol_rate", 100.0),
-            "shift_hz": sp.get("shift_hz", 170.0),
-            "center_hz": sp.get("center_hz", 0.0),
-            "mode": sp.get("mode", "F1B"),
-            "pre_silence_ms": sp.get("pre_silence_ms", 25.0),
-            "carrier_sec": sp.get("carrier_sec", 0.020),  # 20 ms per ITU-R M.493
-            "post_silence_ms": sp.get("post_silence_ms", 25.0),
-            "noise_dbfs": sp.get("noise_dbfs", -60.0),
-            "normalize": sp.get("normalize", True),
-            "rng_seed": sp.get("rng_seed", 12345),
-        }
-    }
-
-    # Генерируем IQ
-    return generate_dsc_hf(params)
+from dsc_vhf import build_primary_symbols_from_cfg, build_dsc_bits  # переиспользуем VHF-хелперы
+
+def build_dsc_hf(profile: dict) -> np.ndarray:
+    """
+    HF в стиле VHF: Builder/HEX → 10-бит DSC → AFSK(1300/2100 @1200Bd) → FM → pre/carrier/post
+    По умолчанию mode='vhfstyle'. При желании 'f1b'/'j2b' оставляем как альтернативу.
+    """
+    sp = profile.get("standard_params", {})
+    input_mode = sp.get("input_mode", "hex").lower()
+    mode = sp.get("mode", "vhfstyle").lower()
+
+    # 1) Подготовить HEX так же, как в VHF
+    if input_mode == "builder":
+        dsc_cfg = {
+            "scenario": sp.get("call_type", "all_ships").lower().replace(" ", "_"),
+            "mmsi": sp.get("mmsi_to", "111222333"),
+            "format_symbol": sp.get("format_symbol", None),
+            "telecommand_symbols": sp.get("telecommand_symbols", [126, 126]),
+            "mmsi_from": sp.get("mmsi_from", "999888777"),
+            "category_symbol": sp.get("category_symbol", 100),
+        }
+        primary_symbols = build_primary_symbols_from_cfg(dsc_cfg)
+        eos_symbol = int(sp.get("eos_symbol", 127))
+        bits = build_dsc_bits(primary_symbols, eos_symbol=eos_symbol)
+        nbytes = (bits.size + 7)//8
+        padded = np.zeros(nbytes*8, dtype=np.uint8); padded[:bits.size] = bits
+        hex_message = np.packbits(padded).tobytes().hex().upper()
+    elif input_mode == "hex":
+        hex_message = sp.get("hex_message", "D5AA55D5AA55")
+    else:
+        raise ValueError(f"Неизвестный input_mode: {input_mode}")
+
+    if mode in ("vhfstyle", "afskfm"):
+        params = {
+            "device": profile.get("device", {}),
+            "standard_params": {
+                "hex_message": hex_message,
+                "symbol_rate": sp.get("symbol_rate", 1200.0),
+                "f_mark_hz": sp.get("f_mark_hz", 2100.0),
+                "f_space_hz": sp.get("f_space_hz", 1300.0),
+                "pre_silence_ms": sp.get("pre_silence_ms", 25.0),
+                "carrier_sec": sp.get("carrier_sec", 0.16),
+                "post_silence_ms": sp.get("post_silence_ms", 25.0),
+                "fm_dev_hz": sp.get("fm_dev_hz", 2500.0),
+                "preemphasis": sp.get("preemphasis", False),
+                "noise_dbfs": sp.get("noise_dbfs", -60.0),
+                "normalize": sp.get("normalize", True),
+                "rng_seed": sp.get("rng_seed", 12345),
+            }
+        }
+        return generate_dsc_hf_afsk_vhfstyle(params)
+    elif mode in ("f1b", "j2b"):
+        # старая HF-реализация (100Bd/170Hz) остаётся как альтернативная
+        params = {
+            "device": profile.get("device", {}),
+            "standard_params": {
+                "hex_message": hex_message,
+                "symbol_rate": sp.get("symbol_rate", 100.0),
+                "shift_hz": sp.get("shift_hz", 170.0),
+                "center_hz": sp.get("center_hz", 0.0),
+                "mode": "F1B" if mode=="f1b" else "J2B",
+                "pre_silence_ms": sp.get("pre_silence_ms", 25.0),
+                "carrier_sec": sp.get("carrier_sec", 0.020),
+                "post_silence_ms": sp.get("post_silence_ms", 25.0),
+                "noise_dbfs": sp.get("noise_dbfs", -60.0),
+                "normalize": sp.get("normalize", True),
+                "rng_seed": sp.get("rng_seed", 12345),
+            }
+        }
+        return generate_dsc_hf(params)
+    else:
+        raise ValueError(f"Неизвестный mode: {mode}")
```

– Так мы **буквально повторяем** VHF-путь (Builder→10-бит→HEX→AFSK→FM) и оставляем «HF-точный» F1B/J2B как опцию.  

### 2) Дефолты для HF-как-VHF

Убедитесь, что `generate_dsc_hf_afsk_vhfstyle` держит те же дефолты, что VHF:
`symbol_rate=1200.0, f_mark_hz=2100.0, f_space_hz=1300.0, fm_dev_hz=2500.0, pre_silence_ms=25, carrier_sec=0.16, post_silence_ms=25, noise_dbfs=-60, preemphasis=False, normalize=True`. (У вас это уже так и прописано.) 

---

## Как пользоваться после правок

* **HF как VHF (по умолчанию):**

  ```python
  profile = {
      "device": {"fs_tx": 1_000_000},
      "standard_params": {
          "mode": "vhfstyle",         # можно не указывать — это дефолт
          "input_mode": "builder",    # или "hex"
          "call_type": "all_ships",   # или "individual"/"distress"
          "mmsi_to": "111222333",
          "mmsi_from": "999888777",
          "category_symbol": 100,
          "pre_silence_ms": 25.0,
          "carrier_sec": 0.16,
          "post_silence_ms": 25.0,
          "fm_dev_hz": 2500.0,
      }
  }
  iq = build_dsc_hf(profile)
  ```

* **HF “по стандарту HF” (100Bd/170Hz):**

  ```python
  profile["standard_params"].update({
      "mode": "f1b",          # или "j2b"
      "symbol_rate": 100.0,
      "shift_hz": 170.0,
      "center_hz": 0.0,
  })
  iq = build_dsc_hf(profile)
  ```

---

## Зачем так лучше

* Один и тот же **Builder** и 10-битный стек для VHF/HF — меньше дублирования, одинаковые тесты/HEX/профили. 



