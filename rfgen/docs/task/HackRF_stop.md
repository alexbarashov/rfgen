### фиксим практику под твоё железо: в **rfgen** делаем «псевдонепрерывную» передачу без зависаний, **без `-c` и без `-R`**. 

# ТЗ: Псевдонепрерывная TX для HackRF в rfgen

## 0) Базовый принцип

* Передаём **серией коротких сегментов** `hackrf_transfer -n <samples>`, каждый 1–3 секунды.
* Между сегментами — микропаузa 10–50 мс (на запуск следующего процесса). На спектре воспринимается как **непрерывный сигнал**.
* **Никогда** не использовать:

  * `-c <amp>` (DC-режим) — даёт «залипы».
  * `-R` (repeat) — сложно корректно остановить на твоём экземпляре.

## 1) Параметры и расчёты сегмента

* Пусть `Fs` — частота дискретизации (например, `2 000 000` S/s).
* Длительность одного сегмента `Tseg = 2.0` s (допустимый диапазон: `1.0…3.0` s).
* Число сэмплов на сегмент: `N = int(Fs * Tseg)` → например `4 000 000` при 2 MS/s.
* Выбираем `Tseg=2s` как дефолт: это устойчивая длина, процесс стартует быстро, а пауза ~10–50 мс.

## 2) Формирование сигнала

* **Чистая несущая (CW):** генерировать SC8-файл длиной **ровно `N` сэмплов** с желаемой формой:

  * Вариант A (несущая на `CENTER+IF`): IQ-тон `I=cos(2π·IF·t)`, `Q=sin(…)`, амплитуда 60–100 (int8).
  * Вариант B (несущая ровно на `CENTER`): IQ = `(I=const, Q=0)`, но лучше **A**, чтобы не сидеть на DC.
* **AM/FM/PM (простые):** точно так же генерим **сегмент N сэмплов** с соответствующей модуляцией.
* **AIS/406/DSC/NAVTEX и др.:** на первом этапе — тоже как «сегмент N», при необходимости дублируем payload внутрь сегмента.

> Важно: каждый сегмент **самодостаточен** (включая нужные преамбулы/паузы, если это протокол), чтобы «склейка» была незаметной.

## 3) Цепочка сегментов (loop)

* **Рабочий поток** rfgen (не UI-поток!) делает цикл:

  1. Перед стартом — санитарная уборка: `taskkill /IM hackrf_transfer.exe /T /F` (тихо).
  2. Старт: `hackrf_transfer -d <serial> -t <seg.sc8> -f <CENTER> -s <Fs> -x <GAIN> -n <N>`
  3. Дождаться возврата (код `0` или `(-1004)` в выводе — норма).
  4. Проверить флаг «stopRequested». Если **не** запрошен — сразу запускать следующий сегмент.
* Между 2) и 4) **не** делать sleep — только небольшой «защитный» `sleep(0.01…0.05)s`, если надо.
* Если код возврата ≠ 0 и ≠ типового `(-1004)` — логируем и либо **повторяем** попытку (1 ретрай), либо выходим в **error-state**.

## 4) Управление устройством

* Всегда указывать **твой серийник**: `-d 0000000000000000081c69dc2f2b981b`.
* Перед каждым стартом сегмента:

  * убеждаемся, что **нет** активных `hackrf_transfer` (см. п.3.1);
  * параметр `-x` (TX gain) и `-a` (RF amp) выставляются из UI (по умолчанию `-a 0`, `-x 30…40`).
* **Bias tee (`-p`)** — только если реально нужен.

## 5) Стоп (программный)

* Когда пользователь нажимает **Stop**:

  * Ставим флаг `stopRequested=True`; **не** стартуем новый сегмент после завершения текущего.
  * После выхода из цикла выполняем «очистку»:

    * `taskkill /IM hackrf_transfer.exe /T /F` (на всякий случай)
    * `hackrf_info` (сброс сессии libhackrf)
    * «обнуление ЦАП»: `hackrf_transfer -d <serial> -n 1 -c 0 -f <CENTER> -s <Fs> -x 0 -a 0 -p 0`
* Если любое из трёх выдаёт ошибку — логируем, но UI сразу переводим в **Stopped** (чтобы не висел).

## 6) Аварийный стоп (кнопка **Reset**)

* Отдельная кнопка **Reset** всегда доступна:

  1. `taskkill /IM hackrf_transfer.exe /T /F`
  2. `hackrf_info`
  3. `hackrf_transfer -d <serial> -n 1 -c 0 -f <CENTER> -s <Fs> -x 0 -a 0 -p 0`
* Если помогает — UI показывает «Reset OK». Если **Access denied (-1000)** — показать подсказку: «перевтыкай USB/порт, либо перезагрузка».

## 7) UI-поведение

* **Start**: блокирует поля частоты/скорости/усиления; включает индикатор «Running (seg X/Y)».
* **Stop**: мгновенно переводит кнопку в неактивное состояние и ждёт окончания текущего сегмента (до 3 с макс).
* **Reset**: доступна всегда (даже во время Stop), логирует шаги.
* **Status bar**: текущие параметры (`CENTER`, `Fs`, `N`, `GAIN`, `serial`), PID последнего процесса, код возврата.
* Логи — в `out/logs/tx_YYYYMMDD_HHMMSS.log`.

## 8) Предстартовые проверки (1 раз при запуске rfgen)

* `hackrf_info` → получить и запомнить **serial** (или проверить совпадение с настроенным).
* Проверить, что `Fs` из набора поддерживаемых (2–20 MS/s); при необходимости подбирать ближайшую «красивую» величину.
* Очистить старые процессы (`taskkill`).

## 9) Конфликты/ошибки — что показывать

* **Device busy / -1000 Access denied**: явно показывать «Устройство занято другим процессом или USB-стеком. Попробуй Reset (перевтык), затем Start».
* **lib/CLI версии**: если `hackrf_info` и `hackrf_transfer` из разных релизов — предупредить «желательно синхронизировать версии».
* **Невалидные параметры**: частота/скорость вне диапазона — серые поля + подсказка.

## 10) Настройки-по-умолчанию

* `Tseg = 2.0 s`, `Fs = 2 000 000`, `GAIN = 30`, `AMP(int8)=80`, `IF = 25 000` (для CW не на DC).
* **Режимы вкладки Basic**:

  * CW (IF-тон),
  * AM/FM/PM (несложные шаблоны),
  * «User file» (любой SC8-сегмент N сэмплов).
* Для AIS/406/DSC затем сделаем свои генераторы сегментов, но передача — **тем же лупом** `-n`.

## 11) Почему это сработает на твоём HackRF

* Каждый сегмент **сам завершает** TX на устройстве (`hackrf_stop_tx()` внутри CLI), нет висящих бесконечных потоков.
* Стоп — это «не стартовать следующий сегмент» + «обнулить ЦАП», а не «прибить бесконечный процесс».
* Даже если один сегмент «подсел», следующий не пойдёт — устройство освобождается на границе сегмента.

---

### Быстрые готовые профили (для ручного теста из cmd, без UI)

* **2 сек CW на IF=25 кГц (последовательно):**

  ```
  :: сгенерить файл seg_2s.sc8 с тоном IF (1 раз)
  :: далее в цикле гонять:
  hackrf_transfer -d <serial> -t seg_2s.sc8 -f 162000000 -s 2000000 -x 30 -n 4000000
  ```

  (в rfgen это будет автоматизировано: генерация → луп на `-n`)

* **Стоп/Reset (ручной):**

  ```
  taskkill /IM hackrf_transfer.exe /T /F
  hackrf_info
  hackrf_transfer -d <serial> -n 1 -c 0 -f 162000000 -s 2000000 -x 0 -a 0 -p 0
  ```
