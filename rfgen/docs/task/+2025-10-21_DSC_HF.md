**ТЗ для DSC HF (MF/HF)** 

# Цель

Сгенерировать и передавать кадры **DSC MF/HF** на стандартных частотах (2/4/6/8/12/16 МГц), с корректной рамкой и модуляцией **FSK 100 бод, сдвиг 170 Гц (±85 Гц)**. Поддержать два стиля излучения:

* **F1B** — прямое FSK в baseband (±85 Гц вокруг `center_hz`)
* **J2B** — аудио-AFSK 1700 ± 85 Гц для прохождения через SSB-цепочку
  (выбор через `mode`). 

# Область работ

1. **UI-страница “DSC HF”**: сбор профиля, пресет частот, режимы Loop/Finite, HEX/Builder ввод, Start/Stop, Save/Load. 
2. **Генератор baseband-IQ**: формирование тишины/несущей/полезного участка и (опц.) шума, нормализация, запись cf32. Поддержка F1B/J2B, 100 Bd, 170 Гц. 
3. **Бэкенды**:

   * **HackRF** (реальное излучение) — соблюдать частотный инвариант: в эфир уходит `target_hz`, цифровой сдвиг делается в backend.
   * **FileOut** — сохранение в `iq_<Fs>_dsc_hf_<tag>.cf32`.

# Частоты и пресеты

* В UI оставить список: **2187.5 кГц (Distress), 4207.5, 6312.0, 8414.5, 12577.0, 16804.5 кГц**. Выбор обновляет `target_hz`. (Логика уже заложена.) 

# Параметры модуляции и кадра

* **Симв. скорость:** по умолчанию **100.0 Bd**, проверка достаточного `sps` (≥≈10 отсч/символ).
* **Сдвиг:** **170 Гц** (±85 Гц).
* **Режим:** `"F1B"` (по умолчанию) или `"J2B"`.
* **Центр (F1B):** `center_hz` (обычно 0 Гц в baseband).
* **Секции:** `pre_silence_ms` → (опц.) `carrier_sec` → полезный участок → `post_silence_ms`.
* **Шум:** комплексный, уровень `noise_dbfs` (напр., −60 dBFS).
* **Нормализация:** `peak = 0.999`.
  Все эти поля уже предусмотрены в базовом генераторе HF. 

# Ввод данных: HEX и Builder

* **Direct HEX**: строка hex → битовый поток → F1B/J2B тракт. (Проверка: чётная длина HEX.) 
* **Message Builder** (MVP): поля `category / call_type / mmsi_from / mmsi_to / nature / position / utc_time` в UI уже есть; на первом этапе **можно собирать тестовый payload** (или прокинуть их в метаданные и использовать HEX-режим до готовности кодера M.493). Переключатель “Direct HEX / Message Builder” уже реализован. 

# Профиль (единая схема)

```json
{
  "standard": "dsc_hf",
  "standard_params": {
    "input_mode": "hex|builder",
    "hex_message": "...",
    "symbol_rate": 100.0,
    "shift_hz": 170.0,
    "mode": "F1B|J2B",
    "center_hz": 0.0,
    "pre_silence_ms": 25.0,
    "carrier_sec": 0.0,
    "post_silence_ms": 25.0,
    "noise_dbfs": -60.0,
    "normalize": true
  },
  "schedule": { "mode": "loop|repeat", "gap_s": 8.0, "repeat": 5 },
  "device": {
    "backend": "hackrf|fileout",
    "fs_tx": 1_000_000,
    "tx_gain_db": 30,
    "pa": false,
    "target_hz": 2_187_500, "if_offset_hz": 0, "freq_corr_hz": 0
  }
}
```

UI уже собирает почти такой профиль и умеет Save/Load/Validate. 

# Поведение UI

* **Start TX**:

  1. собрать профиль;
  2. вызвать генератор HF для получения baseband IQ (согласно `mode` F1B/J2B);
  3. backend=fileout — сохранить; backend=hackrf — передать в ТХ (loop/finite).
     Кнопки/статус уже частично реализованы (плейсхолдеры). 
* **Stop**: корректно остановить backend, вернуть кнопки/статус. (UI-каркас готов.) 

# Backend и частотный инвариант

* **Инвариант частот (как и в VHF/TX):**
  `center_hz = target_hz + if_offset_hz + freq_corr_hz` (LO),
  `digital_shift_hz = -(if_offset_hz + freq_corr_hz)`,
  итоговый RF всегда = `target_hz`.
* **Loop/Repeat:**

  * Loop — кадр содержит весь цикл (включая `post_silence` как gap) и гоняется по кругу.
  * Repeat — backend отправляет N копий, между ними вставляет паузы `gap_s`.

# Валидации и ошибки

* `symbol_rate <= 0` → ошибка.
* `shift_hz <= 0` → ошибка.
* `fs_tx / symbol_rate < 10` → ошибка «Fs too low for requested symbol_rate». 
* Некорректный HEX (нечётная длина) → ошибка. 

# Логи и метрики

* В UI — короткий статус (Started/Stopped/Profile loaded). 
* В генераторе/бэкенде — длительность, Fs, размер, пиковый уровень, используемый режим (F1B/J2B), частоты (`target/center/shift`), режим расписания.

# Приёмочные кейсы (smoke)

1. **FileOut / F1B**: `Fs=48 000`, `symbol_rate=100`, `shift_hz=170`, `center_hz=0`, `carrier_sec=0.2`, `noise_dbfs=-50`, `normalize=true` → файл `dsc_hf_F1B_100bd_170shift_48k.iq`, пик ≤ 0.999. (Есть self-test шаблон.) 
2. **HackRF / Loop**: `target=2187500`, `if_offset=+37000`, `corr=0` → LO=≈2224500, цифровой сдвиг −37000 → RF=2187500.
3. **J2B smoke**: `mode=J2B`, проверить спектр аудио 1700 ± 85 Гц в результирующем baseband куске (для последующего SSB-апмода). 
4. **HEX guard**: нечетный HEX → понятное сообщение об ошибке. 

# Известные мелочи / TODO

* Проверить запись interleaved float32 I/Q в генераторе HF (в коде помета «will fix below» — убедиться, что фактическая запись I/Q корректна и согласована с FileOut/HackRF). 
* Builder-режим: на MVP допускается прокидывать собранные поля в HEX-генерацию тестового payload; полноценное кодирование по **ITU-R M.493 / M.541** добавить вторым этапом.
