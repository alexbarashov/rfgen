### реализовать **загрузку профиля** в Quick TX из `rfgen/profiles/` и авто-заполнение формы.

# Цель

* Пользователь выбирает `.json` из `rfgen/profiles/`.
* Значения из профиля маппятся в виджеты Quick TX.
* Валидация, умные значения по умолчанию, статусы/ошибки.

# Базовые требования

1. **Пути**
   Использовать централизованные функции (см. предыдущее ТЗ):

   ```python
   from ...utils.paths import profiles_dir
   ```

   Никаких `parents[...]`.

2. **UI: кнопка “Load Profile…”**
   В `rfgen/ui_qt/pages/page_quick.py`:

   * Добавить кнопку рядом с “Save as Profile…”.
   * Обработчик `self.btn_load.clicked.connect(self._load_profile_dialog)`.

3. **Диалог выбора файла**

   ```python
   from PySide6.QtWidgets import QFileDialog
   pdir = str(profiles_dir())
   path, _ = QFileDialog.getOpenFileName(self, "Load Profile", pdir, "Profiles (*.json)")
   if not path: return
   self._load_profile(Path(path))
   ```

4. **Загрузка и валидация**

   ```python
   def _load_profile(self, path: Path):
       try:
           data = json.loads(path.read_text(encoding="utf-8"))
       except Exception as e:
           QMessageBox.critical(self, "Load failed", f"Can't read profile:\n{e}")
           return
       ok, msg = self._validate_profile(data)
       if not ok:
           QMessageBox.critical(self, "Invalid profile", msg)
           return
       self._apply_profile_to_form(data)
       self._status(f"Profile loaded: {path}")
   ```

5. **Схема/валидация (минимум)**

   * Обязательные блоки: `device`, `modulation`, `pattern`, `schedule`.
   * Поля по умолчанию, если отсутствуют:

     ```python
     defaults = {
       "device": {"backend": "hackrf", "fs_tx": 2_000_000, "tx_gain_db": 30, "pa": False,
                  "target_hz": 0, "if_offset_hz": 0, "freq_corr_hz": 0},
       "modulation": {"type": "None", "deviation_hz": 5000, "pm_index": 1.0, "am_depth": 0.5},
       "pattern": {"type": "Tone", "tone_hz": 1000, "bitrate_bps": 9600},
       "schedule": {"mode": "loop", "gap_s": 0.0, "repeat": 1},
     }
     ```
   * `type` мод. ∈ {None, AM, FM, PM}; `backend` ∈ {hackrf, fileout}; числовые поля — int/float ≥0.
   * Возврат `(True, "")` или `(False, "что не так")`.

6. **Маппинг полей → виджеты**

   ```python
   def _apply_profile_to_form(self, p):
       # Device
       self.combo_backend.setCurrentText(str(p["device"].get("backend", "hackrf")))
       self.fs_tx.setValue(int(p["device"].get("fs_tx", 2_000_000)))
       self.tx_gain.setValue(int(p["device"].get("tx_gain_db", 30)))
       self.pa_enable.setChecked(bool(p["device"].get("pa", False)))
       self.target_hz.setText(str(int(p["device"].get("target_hz", 0))))
       self.if_offset_hz.setText(str(int(p["device"].get("if_offset_hz", 0))))
       self.freq_corr_hz.setText(str(int(p["device"].get("freq_corr_hz", 0))))

       # Modulation
       self.combo_mod.setCurrentText(str(p["modulation"].get("type", "None")))
       self.deviation.setValue(int(p["modulation"].get("deviation_hz", 5000)))
       self.pm_index.setValue(float(p["modulation"].get("pm_index", 1.0)))
       self.am_depth.setValue(float(p["modulation"].get("am_depth", 0.5)))

       # Pattern
       self.combo_pat.setCurrentText(str(p["pattern"].get("type", "Tone")))
       self.tone_hz.setValue(int(p["pattern"].get("tone_hz", 1000)))
       self.bitrate.setValue(int(p["pattern"].get("bitrate_bps", 9600)))

       # Schedule
       mode = str(p["schedule"].get("mode", "loop")).lower()
       self.loop.setChecked(mode == "loop")
       self.repeat.setValue(int(p["schedule"].get("repeat", 1)))
       self.gap_s.setValue(float(p["schedule"].get("gap_s", 0.0)))
   ```

7. **Функция валидации (скетч)**

   ```python
   def _validate_profile(self, p: dict):
       def need(key): 
           if key not in p: return False, f"Missing top-level '{key}'"
           return True, ""
       for k in ("device","modulation","pattern","schedule"):
           ok,msg = need(k)
           if not ok: return ok,msg
       # enums
       if p["device"].get("backend") not in ("hackrf","fileout"):
           return False, "device.backend must be 'hackrf' or 'fileout'"
       if p["modulation"].get("type") not in ("None","AM","FM","PM"):
           return False, "modulation.type must be None/AM/FM/PM"
       # numerics (примеры)
       try:
           fs = int(p["device"].get("fs_tx", 0)); 
           if fs <= 0: return False, "device.fs_tx must be >0"
       except Exception: return False, "device.fs_tx must be int"
       # аналогично для остальных по необходимости
       return True, ""
   ```

8. **Загрузка “по умолчанию”**

   * Опционально: запоминать последний открытый профиль `self._last_profile_path` и подсвечивать в статусе.
   * Опционально: кнопка **Reload** для повторной загрузки.

9. **Миграция старых профилей**
   Перед `QFileDialog` одноразово вызвать:

   ```python
   from ...utils.migrate import migrate_legacy_profiles
   moved = migrate_legacy_profiles()
   if moved:
       self._status(f"Migrated {moved} legacy profiles to rfgen/profiles")
   ```

10. **Ошибки/UX**

* Любая ошибка чтения/валидации — `QMessageBox.critical`, не трогаем текущие поля формы.
* Успех — статус-бар: `Profile loaded: <имя>`.

11. **Тесты (минимум)**

* Фиктивный профиль в `profiles_dir()` → загрузка → проверка, что поля виджетов получили нужные значения (через методы-геттеры или доступ к свойствам).
