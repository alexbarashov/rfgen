
### 1) реализация генератора 121.5 МГц (AM тон/свип/ключ CW) 

121p5.py

**Почему так:** структура и поведение полностью зеркалят PSK-406-генератор — один кадр baseband + встроенный gap в режиме `loop`, а/м огибающая либо ключ (CW), и нормализация к безопасному пику. Это ложится на вашу радиочасть (HackRF runner) без дополнительных правок и сохраняет инвариант RF=target. 


### 2) `wave_engine.py` — маршрутизация: если `standard=="121"`, отдать новый генератор

```diff
*** a/wave_engine.py
--- b/wave_engine.py
@@
 def build_iq(profile: dict, frame_s: float = 1.0):
     """
     Генерация IQ-буфера на основе профиля.
 
     Для standard="c406" или "psk406" вызывает build_psk406().
-    Для остальных стандартов использует pattern + modulation.
+    Для standard="121" вызывает am_121p5.generate_121p5().
+    Для остальных стандартов использует pattern + modulation.
     """
     standard = profile.get("standard", "basic")
 
     # PSK-406: специальная обработка
     if standard in ("c406", "psk406"):
         return build_psk406(profile)
+
+    # 121.5 MHz AM: специальная обработка (как PSK-406 по расписанию/loop)
+    if standard == "121":
+        # импорт локально, чтобы избежать циклов импортов
+        from .am_121p5 import generate_121p5
+        # передаём длительность кадра «мягко» через служебное поле
+        prof = dict(profile)
+        prof["_frame_s"] = frame_s
+        return generate_121p5(prof)
 
     # Базовая генерация (basic, ais, dsc_vhf, и т.д.)
     fs = int(profile["device"]["fs_tx"])
     pat = profile["pattern"]["type"]
     tone_hz = float(profile["pattern"].get("tone_hz", 1000.0))
```

Это минимальная точка входа: не ломает существующие стандарты, добавляет «121» как первый-класс гражданин, и ре-использует вашу модель расписания (loop/finite + gap) и TX-пайплайн. 

---

### Как это работает вместе с вашим TX-контуром

* Генератор 121.5 возвращает **baseband** IQ (несущая = 0 Гц) — ровно как PSK-406.

* Частоты/сдвиги считаются и применяются **в `hackrf.py`**:
  `center_hz = target_hz + if_offset_hz + freq_corr_hz`,
  `digital_shift_hz = -(if_offset_hz + freq_corr_hz)`,
  инвариант: `center_hz + digital_shift_hz == target_hz` (в эфир уходит `target_hz`). 

* `Page121` уже собирает профиль с нужными полями (`standard="121"`, `standard_params.signal_type/tone/sweep/am_depth/duty`, `schedule.mode/gap_s/repeat`, `device.*`). Кнопки Start/Stop пока «заглушки» — генерация и TX подтянутся туда же, где сейчас подключён PSK-406/прочие страницы. 

* При необходимости последующего **ресемплинга** (если для 121 захотите иное Fs кодака/ЦАП) — используйте ваш `resample()` до конвертации в sc8. 

* Генерация PSK-406 (для ориентира по структуре «кадр+gap в loop») — см. вашу реализацию; 121 делает то же самое, только AM вместо BPSK.  

---

### Быстрый чек-лист интеграции

1. Вставьте патчи выше.
2. В вашем месте вызова `build_iq(profile, frame_s=1.0)` просто укажите `profile["standard"] = "121"`.
3. Для «Swept Tone» поставьте в UI `300–1600 Гц`, `sweep_rate`≈2 Гц/с (как по умолчанию на странице), `AM depth`=0.8, `duty`=1.0.
4. Для «CW» — выберите *Modulated Carrier (CW)* и поставьте `duty` (например, 0.5 для полукадра «включено»).
5. Тюнинг RF делайте ровно как для PSK-406: `target_hz=121500000`, `if_offset/freq_corr по ситуации` — остальное выполнит `hackrf.py`. 
