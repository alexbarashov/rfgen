делаем «DSC VHF TX» 

# Цель

Передавать сообщения DSC на VHF канале 70 (156.525 МГц) с корректной рамкой (phasing + primary symbols + time-diversity), аудиочасть AFSK 1300/2100 Гц @ 1200 Bd, поверх ЧМ (FM deviation задаётся), с двумя режимами расписания (loop / finite), инвариантом частот и единым профилем настроек.

# Область

* Генерация baseband IQ (complex64) сигнала DSC.
* FM-модуляция аудио AFSK.
* Тюнинг RF через backend HackRF или FileOut.
* Профили UI с сохранением/загрузкой.
* Логи и метрики при TX.

# Норматив / основы (как уже заложено в коде)

* AFSK (mark=2100 Гц, space=1300 Гц) @ 1200 Bd формируется из битового потока HEX/символов; FM девиация по пику аудио |1| соответствует параметру `fm_dev_hz`; секции: pre-silence → carrier → FM(AFSK) → post-silence; нормализация уровня к безопасному пику. 
* UI-страница «DSC VHF» уже содержит каркас полей профиля, режимы Loop/Finite, частоты и target/offset/corr. Нужно связать кнопки Start/Stop с реальной передачей. 
* Движок волн/базовый билдеры уже реализуют «baseband-как-инвариант» (все сдвиги/компенсации — в backend), а также правило: в loop-режиме gap включается в кадр; в repeat-режиме gap добавляет backend. Использовать одинаковую семантику для DSC. 
* Ресемплер есть (linear, cf32 IQ). Применять только при необходимости приведения Fs. 
* HackRF backend фиксирует инвариант частот:
  `center_hz = target_hz + if_offset_hz + freq_corr_hz` (LO),
  `digital_shift_hz = -(if_offset_hz + freq_corr_hz)`,
  и тем самым `RF out = target_hz` всегда; умеет loop/repeat, конвертирует cf32→sc8, логирует метрики. Этим же путём идём для DSC. 

# Архитектура и поток данных

1. **UI (PageDSC_VHF)** → собирает `profile` (standard="dsc_vhf"): device, schedule, standard_params. Кнопка Start вызывает TX-пайплайн; Stop — останов backend. 
2. **DSC Builder** (внутри dsc_vhf.py):

   * Builder «primary symbols» (format/address/telecommands) → 10-бит кодирование (7 инфо + 3 check) → phasing → time-diversity → битовый поток.
   * Генерация аудио AFSK 1300/2100 Гц @ 1200 Bd → опциональный pre-emphasis → FM в baseband IQ → склейка секций → нормализация. 
3. **Wave engine** (общая обвязка): при необходимости вызывать DSC-генератор (standard="dsc_vhf") и возвращать baseband IQ (Fs из профиля). Семантика loop gap как в PSK406. 
4. **Backend**:

   * **HackRF**: применяет digital shift (компенсацию IF+corr), конвертирует в sc8, запускает `hackrf_transfer` в loop/repeat, ведёт логи/метрики. 
   * **FileOut**: сохраняет cf32 (или sc8) с именованием `iq_<Fs>_dsc_<tag>.cf32`.

# Профиль (ключи и семантика)

* `standard: "dsc_vhf"`
* `standard_params`:

  * `input_mode`: "hex" | "builder" (UI переключатель). 
  * `hex_message`: сырой DSC payload в HEX (если input_mode=hex). 
  * **builder-поля**: `category`, `call_type`, `mmsi_from`, `mmsi_to`, `nature`, `position`, `utc_time` — используются для сборки `primary_symbols` (если input_mode=builder). (Маппинг описан ниже.) 
  * AFSK/FM/рамка:

    * `symbol_rate` (default 1200.0), `f_mark_hz` (2100.0), `f_space_hz` (1300.0),
    * `fm_dev_hz` (default 2500.0), `preemphasis` (bool),
    * `pre_silence_ms` (25), `carrier_sec` (0.16), `post_silence_ms` (25),
    * `normalize` (True), `noise_dbfs` (-60 dBFS). 
* `device`:

  * `backend`: "hackrf" | "fileout" (UI), `fs_tx` (Гц), `tx_gain_db`, `pa` (bool),
  * `target_hz`, `if_offset_hz`, `freq_corr_hz` — по инварианту частот.
* `schedule`:

  * `mode`: "loop" | "repeat",
  * `gap_s`: пауза между кадрами,
  * `repeat`: N (для repeat). (Loop — gap вшит в кадр.)

# Сборка сообщения (builder → primary symbols)

* **Phasing**: как в dsc_vhf.py (`_build_phasing_symbols()`), далее time-diversity. 
* **Адресация и формат**: пресеты:

  * *All Ships*: `format_symbol = 112`; адрес — MMSI получателя, разбитый на пары цифр (00..99) → 5 символов; telecommand по умолчанию [126,126]. 
  * *Individual*: `format_symbol = 120`; *Distress* — оставить переопределяемым (формат задаётся `format_symbol`). 
* **HEX режим**: если указан `hex_message`, он напрямую конвертируется в биты и идёт в AFSK-аудио (без builder). 

# FM/AFSK тракт

* Генерация для каждого бита: синус 1300/2100 Гц, `sym_N = Fs / 1200`; опция лёгкого pre-emphasis; нормировка аудио к |1| перед FM; интеграция фазы в float64; комплексный FM в baseband; секции тишины/несущей до/после. 
* Нормализация пика и опциональная инъекция комплексного шума (-60 dBFS по умолчанию). 

# Backend и частоты

* **Инвариант (строго):**
  `center_hz = target_hz + if_offset_hz + freq_corr_hz`
  `digital_shift_hz = -(if_offset_hz + freq_corr_hz)`
  `RF out = center_hz + digital_shift_hz = target_hz`.
  DSC-кадр генерится всегда **в baseband** (0 Гц), цифровой сдвиг — только в backend. 
* **HackRF**:

  * При loop: использовать один frame (включая post-silence=gap) + флаг `-R`.
  * При repeat: конкатенировать (frame + нули-gap)*repeat, запуск без `-R`.
  * Автолог метрик (RMS/Peak), путей файлов, частот, режима, оценки длительности. 
* **FileOut**: сохранить cf32 кадр на диск (именование `iq_<Fs>_dsc_<stamp>.cf32`).

# UI-поведение (PageDSC_VHF)

* Кнопка **Start TX**:

  1. собрать профиль;
  2. построить IQ (DSC generator);
  3. если backend=fileout — просто сохранить; если backend=hackrf — отдать в HackRF Tx (loop/repeat согласно schedule).
  4. заблокировать Start, разблокировать Stop, статус «Transmitting…». 
* Кнопка **Stop**: вызвать `HackRFTx.stop()`, статус «Stopped», вернуть кнопки. (Останавливание уже надёжно реализовано через terminate→kill→taskkill.) 
* Профили: Save/Load — как сейчас, поле `standard` = "dsc_vhf". Проверка валидности — существующей валидацией. 

# Ошибки и защита

* Если `fs_tx / 1200 < 10` — ошибка «Fs too low for symbol_rate» (уже есть в генераторе). 
* Если HEX нечётной длины/невалидный — понятное сообщение (есть проверка/исключение). 
* Если файл IQ пуст/отсутствует — останов и понятная ошибка в статусе. (Поведение аналогично текущему HackRF runner.) 

# Логи/метрики

* В UI краткий статус (Started/Stopped/Profile loaded/saved). 
* В backend подробный лог: cmd, PID, входной файл, формат, метрики RMS/Peak, частоты, расписание, длительность, предупреждение при слишком малом пике. 

# Тестовые шаблоны / приёмка

1. **Smoke (loop/fileout)**:

   * Fs=1 000 000, HEX="D5AA55D5AA55", fm_dev=2500 Гц, pre=25 мс, carr=0.16 с, post=8 с (gap) → файл `dsc_cf32.iq`, пик ≤0.999. 
2. **HackRF(loop)**: target=156 525 000, if_offset=+37 000, corr=0 → LO=156 562 000, digital_shift=-37 000 → RF=156 525 000. В логе совпадение invariant. 
3. **HackRF(repeat)**: repeat=5, gap=3 с, оценка суммарной длительности в логе; воспроизведение без -R. 
4. **HEX vs Builder**: идентичность длительности AFSK-части при одинаковом количестве бит; правильная генерация phasing + time-diversity (визуальный/анализ аудио-тонов). 
5. **Ресемпл** (опционально): при несоответствии Fs — привести к `fs_tx` и сверить длительность. 

# Маппинг UI → Builder

* `call_type`, `category`, `mmsi_from`, `mmsi_to`, `nature`, `position`, `utc_time` → функция построения `primary_symbols`:

  * пока минимум MVP: All Ships / Individual с MMSI, формат 112/120, телекоманды по умолчанию `[126,126]`; Distress/прочие — расширяем позже (таблицы ИТУ). 

# Будущее расширение (после MVP)

* Полная матрица форматов/категорий/причин бедствия и т.п. по ITU-R M.493 (кодирование символов и EOS/ACK-сценарии).
* Генерация нескольких кадров в одной сессии с автоматическим интервалом и номером кадра в логе.
* Валидация MMSI, позиция/время, auto-UTC.
* Генерация `.wav` аудио AFSK для лабораторных приёмников (доп. опция).


