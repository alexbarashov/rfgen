### нужно протестировать **Stop** и понять, почему он не гасит `hackrf_transfer`.

# Цель

Гарантированно останавливать запущенный через UI процесс `hackrf_transfer` на Windows. Видеть в логах, **когда/чем** мы его гасим и чем закончился процесс.

---

# Что править

## 1) Централизовать пути логов

**Новый файл:** `rfgen/utils/paths.py` (если ещё нет)

```python
from pathlib import Path

def pkg_root() -> Path:
    return Path(__file__).resolve().parents[1]  # .../rfgen/

def logs_dir() -> Path:
    p = pkg_root() / "logs"
    p.mkdir(parents=True, exist_ok=True)
    return p
```

## 2) Backend: усилить управление процессом HackRF

**Файл:** `rfgen/backends/hackrf.py` — заменить класс на такой (без внешних зависимостей):

```python
import subprocess, os, time, datetime
from pathlib import Path
from ..utils.paths import logs_dir

CREATE_NEW_PROCESS_GROUP = getattr(subprocess, "CREATE_NEW_PROCESS_GROUP", 0)

class HackRFTx:
    def __init__(self, exe: str = "hackrf_transfer"):
        self.exe = exe
        self.proc: subprocess.Popen | None = None
        self.pid: int | None = None
        self.log_path: Path | None = None
        self.cmdline: list[str] | None = None

    def _open_log(self) -> tuple[Path, int]:
        ts = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
        path = logs_dir() / f"hackrf_{ts}.log"
        fh = open(path, "a", buffering=1, encoding="utf-8")
        fh.write(f"[{ts}] log started\n")
        return path, fh

    def run_loop(self, iq_path: Path, fs_tx: int, center_hz: int, tx_gain_db: int):
        """Стартуем hackrf_transfer в -R. Вывод → лог. Храним PID/cmdline."""
        if self.is_running():
            raise RuntimeError("HackRF already running")

        cmd = [
            self.exe, "-t", str(iq_path),
            "-f", str(int(center_hz)),
            "-s", str(int(fs_tx)),
            "-x", str(int(tx_gain_db)),
            "-R"
        ]
        self.cmdline = cmd

        # Логи stdout+stderr в файл
        self.log_path, log_fh = self._open_log()
        flags = CREATE_NEW_PROCESS_GROUP if os.name == "nt" else 0
        self.proc = subprocess.Popen(
            cmd,
            stdout=log_fh, stderr=subprocess.STDOUT,
            creationflags=flags
        )
        self.pid = self.proc.pid

        # Заголовок в логе
        try:
            with open(self.log_path, "a", encoding="utf-8") as f:
                f.write(f"CMD: {' '.join(cmd)}\n")
                f.write(f"PID: {self.pid}\n")
                f.write(f"IQ: {iq_path}\n\n")
        except Exception:
            pass

        return self.proc

    def is_running(self) -> bool:
        return self.proc is not None and (self.proc.poll() is None)

    def stop(self, timeout_sec: float = 1.5):
        """Graceful terminate → wait → force kill; логируем все шаги."""
        if not self.proc:
            return

        try:
            with open(self.log_path, "a", encoding="utf-8") as f:
                f.write(f"\n[stop] sending terminate to PID {self.pid}\n")
        except Exception:
            pass

        # 1) Терминейт
        try:
            self.proc.terminate()
        except Exception:
            pass

        # 2) Ждём
        t0 = time.time()
        while self.is_running() and (time.time() - t0) < timeout_sec:
            time.sleep(0.05)

        # 3) Форс-килл при необходимости
        if self.is_running():
            try:
                with open(self.log_path, "a", encoding="utf-8") as f:
                    f.write("[stop] still running → kill()\n")
            except Exception:
                pass
            try:
                self.proc.kill()
            except Exception:
                pass

        rc = None
        try:
            rc = self.proc.wait(timeout=0.5)
        except Exception:
            pass

        try:
            with open(self.log_path, "a", encoding="utf-8") as f:
                f.write(f"[stop] stopped, returncode={rc}\n")
        except Exception:
            pass

        self.proc = None
        self.pid = None
```

> Примечание: `CTRL_BREAK_EVENT` часто не срабатывает, потому что дочерний процесс не обязательно привязан к нашему консольному сеансу. Схема terminate→wait→kill на Windows надёжнее. Вывод в лог помогает видеть факт остановки.

## 3) UI: правильное управление состояниями кнопок + лог статуса

**Файл:** `rfgen/ui_qt/pages/page_quick.py`

* При старте:

  * отключать `Start` и `Save`, включать `Stop`.
  * После удачного старта — показывать путь к лог-файлу backend’а (если есть).
* При стопе:

  * вызывать `self._hrf.stop()`.
  * всегда после — включать `Start/Save`, отключать `Stop`.
  * статус «HackRF TX stopped (rc=…)» (rc из лога не обязателен, но можно парсить хвост лога).

Скетч правки в обработчиках:

```python
def _start_tx(self):
    # ... генерация sc8 и т.п.
    if backend == "hackrf":
        self._hrf = HackRFTx()
        self._hrf.run_loop(iq_path, fs_tx=fs, center_hz=center, tx_gain_db=tx_gain)
        self.btn_start.setEnabled(False)
        self.btn_save.setEnabled(False)
        self.btn_stop.setEnabled(True)
        log = getattr(self._hrf, "log_path", None)
        if log:
            self._status(f"HackRF TX running (PID {self._hrf.pid}). Log: {log}")
        else:
            self._status(f"HackRF TX running (PID {self._hrf.pid}).")

def _stop_tx(self):
    if self._hrf and self._hrf.is_running():
        self._hrf.stop()
        self._status("HackRF TX stopped.")
    else:
        self._status("Nothing to stop.")
    self.btn_start.setEnabled(True)
    self.btn_save.setEnabled(True)
    self.btn_stop.setEnabled(False)
    self._hrf = None
```

* На время запуска можно добавить «kill stale» (опционально) **перед** стартом:

```python
import subprocess
subprocess.call(["taskkill", "/IM", "hackrf_transfer.exe", "/F"], shell=False)
```

(Только если уверены, что нет других целевых сессий у пользователя.)

---

# Что искать в логах (где, как выглядят)

Логи лежат в: **`rfgen/logs/hackrf_YYYYMMDD_HHMMSS.log`**. Там должны быть строки:

1. При старте:

```
[20251020_121314] log started
CMD: hackrf_transfer -t C:\...\quick_tx_frame.sc8 -f 162000000 -s 2000000 -x 30 -R
PID: 12345
IQ: C:\...\quick_tx_frame.sc8
```

2. Пока идёт передача — обычные строчки `hackrf_transfer`:

```
call hackrf_set_sample_rate(2000000 Hz/2.000 MHz)
... 
3.9 MiB / 1.008 sec = 3.9 MiB/second, amplitude -inf dBfs
Input file end reached. Rewind to beginning.
...
```

3. При нажатии Stop (наши сообщения):

```
[stop] sending terminate to PID 12345
[stop] still running → kill()       # (только если terminate не хватило)
[stop] stopped, returncode=0        # код возврата может быть !=0, это ок
```

## Как интерпретировать

* Если **нет** строк `[stop] ...` → UI не вызывал `stop()` (проверять wiring кнопки).
* Если есть `sending terminate`, но нет `stopped` → процесс завис, вероятно нет прав kill (проверить UAC/антивирус), или PID уже умер (перепроверь `is_running()`).
* Если `stopped, returncode=None` → `wait()` не вернул код (процесс ещё завершался) — увеличить `timeout_sec` до 3–5 c.
* Если в логе параллельно видны **две** сессии `hackrf_transfer` (две пачки `call hackrf_*`) — у тебя две копии висят; стоит включить «kill stale» перед стартом.

---

# Дополнительно (необязательно, но полезно)

* В UI добавить «Kill all HackRF» кнопку (на панель «Quick TX») c вызовом:

  ```python
  subprocess.call(["taskkill","/IM","hackrf_transfer.exe","/T","/F"], shell=False)
  self._status("Killed all hackrf_transfer processes.")
  ```
* В `HackRFTx.run_loop` сохранять **полный** cmdline и PID в доступные поля — мы уже делаем.
* На Windows убедиться, что `shell=False` (сейчас так), чтобы не плодить «промежуточные cmd.exe».

---

# Критерии приёмки

* При Start кнопки переключаются: Start/Save → disabled, Stop → enabled.
* В логе создаётся запись с `CMD`, `PID`, путём к IQ.
* При Stop в логе присутствуют `[stop] ...` и финальная строка с `stopped, returncode=...`.
* Процесс `hackrf_transfer.exe` исчезает из `tasklist` спустя ≤ 2 сек после Stop.
* Повторный Start возможен сразу после Stop (без ручного `taskkill`).
* Нет «зависших» процессов по окончании работы UI.

С этим набором изменений будет понятно, **почему именно** Stop не срабатывал (по логу) и гарантированно гасить передачу в 1–2 шага.
