### ТЗ на **NAVTEX** (518/490/4209.5 кГц) в стиле ваших DSC-HF/AIS модулей, совместимое с текущей архитектурой.

# ТЗ: NAVTEX (SITOR-B, 100 Bd, shift 170 Гц)

## 0) Принципы и совместимость

* **STRICT_COMPAT**: никаких ломающих изменений; только добавления.
* **Baseband-invariant**: генераторы отдают **0 Гц baseband**; сдвиги и LO считаются в backend (HackRF). Инвариант TX:
  `center_hz = target_hz + if_offset_hz + freq_corr_hz`,
  `digital_shift_hz = -(if_offset_hz + freq_corr_hz)`,
  `RF out = target_hz`. Реализация уже есть в `HackRFTx.run_loop(...)`. 
* **Единый профиль**: использовать ту же схему `profile`/`standard_params`, как в `wave_engine` (PSK-406/121 и пр.). Это позволит дергать NAVTEX через общий раннер и страницы. 

---

## 1) Модулятор NAVTEX (новый модуль `standards/navtex.py`)

### 1.1 Минимальный MVP (как уже сделано в `/mnt/data/navtex.py`)

* Режимы:

  * `F1B` — прямой FSK (100 Bd, shift=170 Гц → тона center±85 Гц).
  * `J2B` — аудио AFSK (1700 ± 85 Гц) — для SSB-цепочек.
* Ввод:

  * `input_mode: "hex" | "text"`
  * Для `text` — построитель заголовка: `"ZCZC {STA}{TYPE}{NUM}\r\n" + message + "\r\nNNNN\r\n"` (MVP, без FEC).
* Параметры (в `standard_params`):

  * `symbol_rate: 100.0`, `shift_hz: 170.0`, `center_hz: 0.0`, `mode: "F1B"| "J2B"`.
  * Тайминги: `pre_silence_ms`, `carrier_sec`, `post_silence_ms`.
  * Уровни/шум: `noise_dbfs`, `normalize: bool`.
  * Вывод: `save_path` (cf32 interleaved float32 I/Q).
* Требуемая точность: `Fs_tx / symbol_rate ≥ 10` сэмплов/символ (жестко валидировать).

### 1.2 Полноценный NAVTEX (SITOR-B) — шаг 2

* **Кодек**: CCIR-476 (7-бит, 4-из-7) + SITOR-B FEC (ARQ-двойные символы); межстрочное чередование.
* **Структура передачи**:

  * Фазинг (LTRS/FIGS), служебная строка: `ZCZC` + B1 (станция) + B2 (категория) + B3B4 (номер), CR/LF, тело ≤ 32 строк по 80 симв., `NNNN` (терминатор).
* **Сигнальный план**:

  * Бодовая 100 Bd ровно, расстановка CR/LF и пустых строк согласно NAVTEX; без сдвига фазы/частоты между строками.
* **Согласование символов**: маппинг ITA2 ↔ CCIR-476 с правильными LTRS/FIGS и повтором для FEC.

---

## 2) Интеграция в раннер/движок

### 2.1 `wave_engine`

* Добавить ветку в общий билдер:
  `if standard in ("navtex","navtex_f1b","navtex_j2b"): return standards.navtex.build_navtex(profile)`
  Пример/паттерн — как уже сделано для PSK-406/121 (единый `profile` → генерация IQ). 
* Повторно использовать имеющиеся утилиты (`_hex_to_bits`, нормализация, тайминги) — код-стиль как в PSK-406. 

### 2.2 Backend HackRF

* Ничего не менять: уже есть конвейер **cf32 → digital_shift → sc8 → hackrf_transfer**, инвариант частоты и режимы `loop`/`repeat` + `gap_s`. 

---

## 3) UI/Страницы

### 3.1 `page_navtex.py`

* Поля:

  * Частота: пресеты 518 kHz / 490 kHz / 4209.5 kHz (editable), `target_hz`.
  * Режим: `F1B`/`J2B`.
  * Ввод: `HEX`/`Builder` (`station_id`, `msg_type`, `msg_number`, `message_text`).
  * Тайминги: `pre/post`, `carrier_sec`; `schedule: {mode: loop|repeat, gap_s, repeat}` (как в DSC-HF).
  * Уровни: `noise_dbfs`, `normalize`.
  * `Fs_tx`, `tx_gain_db`, `pa_enabled`, `if_offset_hz`, `freq_corr_hz`.
* Кнопки: **Save IQ**, **Start HackRF**, **Stop** (повторить логику `page_dsc_hf`).
* Fileout: имя вида `navtex_{mode}_{fs}_{freq}_{ts}.cf32`.

### 3.2 Логи/метрики

* В лог-панель выводить сводку (RMS, peak, bytes, loop/repeat, gap, итоговую длительность), как делает `HackRFTx` сейчас. 

---

## 4) Форматы файлов и частоты дискретизации

* **CF32** interleaved I/Q float32 — стандарт системы (читается/пишется в hackrf-потоке). 
* Рекомендуемый `Fs_tx`: 48 к, 96 к, 192 к (для J2B удобно 48 к, для F1B — ≥ 48 к).
* Проверка: `sps = round(Fs_tx / 100) ≥ 10` — иначе ошибка.

---

## 5) Автотюнер/частотные пресеты

* NAVTEX — фиксированные частоты `target_hz`:
  `518000`, `490000`, `4209500` (Гц).
* **Без автодетекта** на первом шаге; только пресеты и ручной ввод.

---

## 6) Тесты и критерии приемки

1. **Smoke**: сгенерировать 3 файла (518/490/J2B@1700 Гц), `Fs_tx=48 к`, `pre=50 мс`, `carrier=200 мс`, `post=50 мс`.
   Проверка: non-zero peak, RMS в разумных пределах; длительность = pre+carrier+N_bits/sym_rate+post.
2. **Loop TX**: `mode=loop`, `gap_s=8` — передача по кругу через HackRF, лог подтверждает инвариант RF=target_hz. 
3. **Repeat TX**: `mode=repeat`, `repeat=5`, `gap_s=2` — сверка суммарной длительности и корректности конкатенации в логе. 
4. **J2B совместимость**: спектр аудио-тонировки 1700 ± 85 Гц (узкая линия на 1700 Гц и смещения на ±85 Гц).
5. **sps guard**: при `Fs_tx=6 к` должно выбрасывать явную ошибку «Fs too low».

---

## 7) CLI/Примеры вызовов

* Генерация IQ (F1B) для 518 кГц:

  * `standard="navtex"`, `symbol_rate=100`, `shift_hz=170`, `mode="F1B"`, `target_hz=518000`.
* Передача:

  * `HackRFTx.run_loop(iq_path, fs_tx, target_hz=518000, tx_gain_db, if_offset_hz, freq_corr_hz, mode="loop", gap_s=8)` — RF=518 кГц гарантировано логикой backend. 

---

## 8) Этап 2 (после MVP)

* Полный SITOR-B кодер + правильный builder NAVTEX-форматирования (B1/B2/B3B4, 80-колоночные строки, CR/LF, `NNNN`).
* Генерация контрольных наборов и кросс-валидация с известными демодуляторами (dl-test).


