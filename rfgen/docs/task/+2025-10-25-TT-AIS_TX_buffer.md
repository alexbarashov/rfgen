### ТЗ. убираем режим «огромного файла на несколько импульсов», добавляем передачу AIS из буфера/файла и правим UI.

# ТЗ: AIS TX — передача из буфера или из файла (без «большого файла»)

## Цель

Сделать модуль передачи AIS, который:

1. умеет **TX из буфера** (в памяти) и **TX из файла** (`.cf32`), аналогично PSK-406;
2. **не** создаёт один гигантский файл на N импульсов; вместо этого:

   * для `repeat='loop'` — один кадр + gap, воспроизводимый `-R` (бесконечно);
   * для `repeat = N` — **N последовательных запусков** backend (каждый — один кадр; для первых `N−1` добавляется gap, последний — без gap);
3. имеет обновлённый UI с явным выбором источника (буфер/файл), repeat и gap.

---

## Область работ

* Модули генерации AIS-кадра (в память) и/или загрузки `.cf32`.
* Backend HackRF TX: повторное использование подхода «406».
* Обновление UI (страницы AIS) и CLI (если есть).
* Логи, ошибки, контроль амплитуды/частоты, очистка temp-файлов.

---

## Режимы передачи

### 1) Источник: **Буфер** (in-memory)

* Генератор собирает **один кадр**: `pre_noise_ms` → `carrier_ms` → «полезный AIS-сегмент» → `post_noise_ms`.

### 2) Источник: **Файл** (`.cf32`)

* Читаем **один кадр** из файла (без мульти-конкатенаций).
* Проверяем Fs файла .
* Валидируем формат (interleaved I/Q float32, little-endian).

---

## Поведение `repeat` и `gap_s`

### `repeat='loop'`

* Формируем **ровно один** кадр (в буфере или из файла) и **встраиваем в конец gap** (тишина).
* Backend сохраняет кадр в temp `.sc8` и запускает `hackrf_transfer -R`.
* Никаких «больших файлов» и внешних циклов нет.

### `repeat = N` (N ≥ 1)

* **Не** конкатенируем кадры заранее.
* Backend выполняет **N последовательных запусков**:

  * Для запусков `1..N-1`: кадр + gap в temp `.sc8`;
  * Для запуска `N`: кадр **без** gap.
* Каждый запуск перезаписывает **один и тот же** temp-файл (или создаёт новый с тем же именем).
* Между запусками выдерживаем технологическую паузу `tx_restart_delay_ms` (конфиг, по умолчанию 50–200 мс), чтобы избежать залипания процесса/USB.

---

## Параметры и интерфейсы

### Общие параметры кадра 

* `pre_noise_ms`, `carrier_ms`, `post_noise_ms`, `noise_dbfs`.
* `level_dbfs` или `amp_scale` (ограничить, чтобы не клиповать SC8).
* `fs_tx`: целевая частота дискретизации для HackRF обычно Fs=2_000_000 (если отличается, ресэмплинг в backend).

### Backend HackRF

* Режимы:

  * `loop`: один запуск `hackrf_transfer -R` с файлом «кадр+gap».
  * `finite`: цикл из N запусков; первые `N−1` — «кадр+gap», последний — «кадр».
* Управление паузой между запусками: `tx_restart_delay_ms`.
* Очистка temp-каталога после завершения.

### Ошибки/валидация

* Несовместимый Fs у `.cf32` → предупреждение, auto-ресэмпл.
* Амплитуда выше 1.0 после нормализации → жёсткий лимит + лог.
* Пустой файл/буфер → отказ с сообщением.
* `repeat < 1` в finite → ошибка валидации.

---

## Обновления UI (страница AIS)

### Переключатели и поля

* **Источник**: `Source = Buffer | File`

  * Если `Buffer`: показываем блок генератора (pre/carrier/post/noise и пр.).
  * Если `File`: поле выбора файла `.cf32` (один кадр), отображение метаданных (Fs, длительность).
* **Repeat**:

  * `Mode = Loop | Finite(N)`
  * `N` (целое ≥ 1), активно только при `Finite`.
* **Gap, s** (float ≥ 0): используется в `loop` и для `finite` в первых `N−1` импульсах.

### Кнопки

* `Start (Loop)` / `Start (N runs)` / `Stop`
* `Dry-run` (собрать кадр, показать длительность кадра и результирующую длительность цикла N, не включая HackRF)

### Отображение статуса/логов

* Для `finite`: счётчик «Run i/N», длительность одного запуска, задержка между запусками.
* Для `loop`: текущая длительность работы, подтверждение `-R`.
* Путь к temp-файлу (только в режиме отладки).
* Предупреждения: ресэмплинг, ограничение амплитуды, клиппинг.

---

## CLI (если используется)

* Пример:

  * `--source buffer|file`
  * `--in path.cf32` (только если `--source=file`)
  * `--repeat loop|N`
  * `--gap-s 0.100`
  * `--level-dbfs -6.0`
  * `--fs-tx 1024000`
  * `--if-offset-hz 0 --freq-corr-hz 0`
  * `--tx-restart-delay-ms 100`
  * `--keep-temp` (debug)

---


## Критерии приёмки

* Нет кода, который создаёт «большой файл на N импульсов».
* `loop` всегда использует **ровно один** кадр с gap и `-R`.
* `finite N` всегда реализован **через N последовательных запусков** (никаких конкатенаций).
* UI/CLI дают пользователю прозрачный контроль источника, repeat, gap.
* Логи понятны: видно источник, Fs, repeat-режим, длительности, уровни, ошибки.
* Temp-файлы удаляются (кроме `keep-temp`).

