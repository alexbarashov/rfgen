### добавить/доделать, чтобы у нас полноценно передавались AIS-сообщения (через HackRF или в файл). 

# ТЗ: Передача AIS (VDL, GMSK 9 600 бод)

## 1) Источник сообщения (payload → биты)

* Поддержать два входа:

  * **NMEA VDM/VDО** строка (ввод в UI). Разобрать `!AIVDM/...` → собрать 6-битный payload → байты → биты.
  * **HEX** (ввод в UI) — трактовать как «уже собранный кадр верхнего уровня», без преобразований.
* На стороне генератора сделать унифицированный объект `AisFrame` (поля: тип, MMSI, payload_bits, длины, повторы и т.д.).
* В UI это уже частично готово: есть секция *Message Configuration* (тип, MMSI, payload-поле). Нам нужно, чтобы «Start TX» реально собирал профиль и запускал передачу, а не «placeholder». 

## 2) Кодирование/формирование кадра (канальный уровень)

> (Коротко — чтобы не спорить о PHY: начинаем с **простого тестового кадра** без «хитрых» шагов; позже добавим NRZI/скремблер/HDLC-фрейминг отдельными флагами.)

* Этапы «минимально рабочие»:

  1. payload_bits → промежуточный битовый поток (без манипуляций);
  2. опционально: прекодирование (NRZI), скремблер, служебные поля/преамбула — **включаем позже** отдельными флагами;
  3. паддинг под целое число символов.
* В генераторе сделать конфиг `standard_params.ais_phy = { "use_nrzi": false, "use_scrambler": false, "add_hdr": false }`, чтобы можно было постепенно включать настоящий PHY.

## 3) GMSK-модуляция 9 600 бод (baseband, cf32)

* В модуле **ais.py** реализовать сборку IQ-буфера: «биты → символы → Гауссов фильтр BT≈0.4 → интегратор (MSK) → `exp(j*phase)` → complex64». Функция-вход: профиль (см. ниже), выход: `np.complex64` baseband.
* В файле сейчас есть заглушка `generate_ais_test(params): pass` — её нужно превратить в рабочий генератор AIS-IQ (или сделать `build_ais(profile)` и дергать её из UI).  
* Частота дискретизации TX берётся из профиля/UI (по умолчанию 2 MS/s). Для удобства оставить простой ресемплер (см. п. 6). 

## 4) Профиль передачи и связь с UI

* В **PageAIS** уже формируется профиль с полями `standard="ais"`, `standard_params`, `device`, `schedule`. Нужно:

  * По **Start TX**: собрать профиль → вызвать генератор AIS-IQ → сохранить `cf32` (имя `iq_<Fs>_ais_<ts>.cf32`) → запустить бекенд (HackRF/fileout) по этому файлу.
  * По **Stop**: останавливать бекенд. Сейчас там «placeholder» — перевести на реальные вызовы. 

## 5) Бэкенд передачи (HackRF)

* Использовать класс **HackRFTx** и его инвариант частот:
  `center_hz = target_hz + if_offset_hz + freq_corr_hz`,
  **цифровой** сдвиг применяется к baseband `cf32`: `digital_shift_hz = -(if_offset_hz + freq_corr_hz)`; итоговый RF выходит **ровно в target_hz**. Это уже реализовано — просто подаём наш `cf32`. 
* Режимы:

  * **repeat**: конкатенация кадр+gap * N (повторы задаёт UI);
  * **loop**: один кадр с «вшитой» паузой — и `-R`.
* Логи уровня/длины кадра уже пишет бекенд — использовать как контроль мощности и длительности. 

## 6) Ресемплирование (если нужно)

* Если генератор работает, скажем, на 384 кС/с, а TX = 2 MS/s, — прогоняем через наш **linear** ресемплер `resample(iq, fs_in, fs_out)` (он уже есть). На выход — `cf32`. 

## 7) Канальная частота / выбор канала

* В UI уже есть Channel A/B и ручной Target (Hz). Меняем только **логику**:

  * При смене канала — подставлять `target_hz` (готово);
  * При запуске — не забыть проставить `if_offset_hz`/`freq_corr_hz` (по умолчанию 0), чтобы соблюсти инвариант RF=target.  

## 8) Сохранение/загрузка профилей

* Уже есть Save/Load профиля. Проверить, что `standard="ais"` подтягивается и правильно мапится обратно в UI. Это уже заготовлено; оставляем как есть. 

## 9) Выходные артефакты и имена файлов

* `cf32`: имя `iq_<fs>_ais_<YYYYMMDD_HHMMSS>.cf32` (как мы договорились в других чатах).
* Логи HackRF уже создаются автоматически и содержат метрики RMS/peak и сводку параметров запуска. Используем их как «паспорт кадра». 

## 10) Мини-чеклист «готово/не готово»

* [ ] UI: кнопка **Start TX** вызывает реальную отправку (а не placeholder). 
* [ ] `ais.py`: генератор GMSK 9 600 бод из битовой полезной нагрузки → `cf32`. 
* [ ] Поддержка двух входов: NMEA VDM/VDО и HEX (парсер VDM можно сделать упрощённым на первом шаге). 
* [ ] Связка с **HackRFTx.run_loop** (repeat/loop + gap/повторы). 
* [ ] (Опционально) Ресемпл до `fs_tx` через `resample`. 
* [ ] В логах: контроль параметров (Fs, длина кадра, RMS/peak, invariant RF). 

---

Если коротко: **собираем профиль из PageAIS → генерируем GMSK-IQ в ais.py → при необходимости ресемплим → сохраняем cf32 → даём HackRFTx.run_loop с target_hz и инвариантом частот**. Реальные «PHY-хитрости» (NRZI/скремблер/HDLC-фрейминг) заведём позже флагами, чтобы не тормозить первую «боевую» передачу.
