### DSC модулятор аккуратные правки с диффами.

# Где сбоит по стандарту ITU-R M.493 и что поправить

1. ## Порядок 10-битного символа (главная проблема)

Сейчас 7 информационных битов для символа собираются **LSB-first**:

```py
def _symbol_to_primary7(sym: int) -> np.ndarray:
    return np.array([(sym >> i) & 1 for i in range(7)], dtype=np.uint8)
```

…а 3 бита «количества нулей» («zero-count») — **MSB-first**. В результате формат символа получается «перевёрнутым» и не проходит проверку на приёмнике. В DSC 10 бит каждого символа должны идти **MSB-first** (сначала старший из 7 информационных, затем 3 бита счётчика нулей — тоже MSB-first).

### Правка

```diff
-def _symbol_to_primary7(sym: int) -> np.ndarray:
-    if not (0 <= sym <= 127):
-        raise ValueError("Symbol out of range 0..127")
-    return np.array([(sym >> i) & 1 for i in range(7)], dtype=np.uint8)
+def _symbol_to_primary7(sym: int) -> np.ndarray:
+    """7 инфо-битов MSB-first: b6,b5,...,b0."""
+    if not (0 <= sym <= 127):
+        raise ValueError("Symbol out of range 0..127")
+    return np.array([ (sym >> k) & 1 for k in range(6, -1, -1) ], dtype=np.uint8)
 
-def _primary7_to_tenbit(info7: np.ndarray) -> np.ndarray:
-    zeros = 7 - int(info7.sum())
-    chk = np.array([(zeros >> 2) & 1, (zeros >> 1) & 1, zeros & 1], dtype=np.uint8)
-    return np.concatenate([info7, chk])
+def _primary7_to_tenbit(info7: np.ndarray) -> np.ndarray:
+    """Добавить 3-битный zero-count (MSB-first) к 7 MSB-first битам."""
+    zeros = 7 - int(info7.sum())
+    chk = np.array([ (zeros >> 2) & 1, (zeros >> 1) & 1, zeros & 1 ], dtype=np.uint8)
+    return np.concatenate([info7, chk])
```

После этой правки ваш демодулятор (и мой) начнёт давать высокий `valid10_ratio` на синтетике и заметно выше на «живых» файлах. 

2. ## FS и построение кадра (phasing/dotting, дублирование FS)

В `_build_dsc_frame()` вы формируете пролог `_build_phasing_symbols()` и затем применяете «time-diversity schedule». Сейчас это **скелет** и не соответствует спецификации (короткая и слегка произвольная последовательность RX/DX; нет гарантированного «dotting»; FS не дублируется явно). В реальном DSC кадр начинается с dotting/phasing, потом **двойной FS (FS FS)**, далее поля (Address×5, Category, SelfID×5, Tele… → EOS, ECC).

### Минимальная доработка каркаса

* Сформировать dotting как несколько **126** подряд (например, 80–160 символов).
* Phasing (RX-последовательности 111..104) — повторить 1–2 раза после dotting.
* Перед payload сделать **два одинаковых FS** (например, 116 для «All ships» или 115/123 для «Individual» — см. ниже п.3).
* В payload включить: Address(5), Category(1), SelfID(5), затем Tele…, EOS(117/122/127), далее **ECC символ**.

Пример мини-патча (не «полная спецификация», но станет сильно ближе к ней):

```diff
-def _build_phasing_symbols() -> List[int]:
-    rx_seq = [111,110,109,108,107,106,105,104]
-    seq = []
-    for i in range(6):
-        seq.append(125)
-        seq.append(rx_seq[i])
-    return seq
+def _build_dotting(n: int = 120) -> List[int]:
+    """Dotting: повтор символа 126."""
+    return [126] * n
+
+def _build_phasing_rx(repeats: int = 2) -> List[int]:
+    """Phasing (RX): 111..104, повторить repeats раз."""
+    base = [111,110,109,108,107,106,105,104]
+    return base * repeats
```

И при сборке кадра:

```diff
-def _build_dsc_frame(primary_symbols: List[int], eos_symbol: int = 127, include_eos: bool = True) -> List[int]:
-    phasing = _build_phasing_symbols()
-    payload = list(primary_symbols)
-    if include_eos:
-        payload.append(eos_symbol)
-    td = _time_diversity_schedule(payload)
-    return phasing + td
+def _build_dsc_frame(primary_symbols: List[int], fs_symbol: int, eos_symbol: int = 127, include_eos: bool = True) -> List[int]:
+    # Dotting + Phasing
+    prefix = _build_dotting(120) + _build_phasing_rx(2)
+    # Обязательное дублирование FS
+    header = [fs_symbol, fs_symbol]
+    payload = list(primary_symbols)
+    if include_eos:
+        payload.append(eos_symbol)
+    # (Time diversity можно временно отключить, чтобы не мешал проверке на приёмнике)
+    return prefix + header + payload
```

3. ## Неверный «default» FS для индивидуального вызова

В `build_primary_symbols_from_cfg()` «individual» даёт `format_symbol = 120` — это **не тот код** (обычно применяют 115 или 123; 116 — «All ships», 112 — «Distress»). Предлагаю дефолт поменять на 115 (или 123), а «All ships» оставить 116. 

```diff
-    if fmt is None:
-        if scenario == "individual":
-            fmt = 120
-        elif scenario == "distress":
-            fmt = 112
-        else:
-            fmt = 112  # all_ships default
+    if fmt is None:
+        if scenario == "individual":
+            fmt = 115   # или 123
+        elif scenario == "distress":
+            fmt = 112
+        else:
+            fmt = 116   # all_ships default
```

4. ## Поля кадра: сейчас их не хватает

Ваш «primary» сейчас — это `[FS] + Address(5) + Tele…` (без Category и SelfID). Для совместимости с парсером на приёмной стороне нужно собирать хотя бы «минимум»: **Address×5, Category, SelfID×5** до телекоманд.

Быстрый апдейт билдера (пример, Category=100=Routine, SelfID берём из `mmsi_from`):

```diff
-def build_primary_symbols_from_cfg(dsc_cfg: dict) -> List[int]:
+def build_primary_symbols_from_cfg(dsc_cfg: dict) -> List[int]:
@@
-    mmsi = str(dsc_cfg.get("mmsi", "111222333"))
-    addr = _mmsi_to_symbols(mmsi)
+    mmsi_to = str(dsc_cfg.get("mmsi", "111222333"))
+    addr = _mmsi_to_symbols(mmsi_to)
+    mmsi_from = str(dsc_cfg.get("mmsi_from", "999888777"))
+    self_id = _mmsi_to_symbols(mmsi_from)
+    category = dsc_cfg.get("category_symbol", 100)  # 100=Routine
@@
-    primary = [int(fmt)] + [int(x) for x in addr] + [int(x) for x in tele]
+    primary = [int(fmt)] + [int(x) for x in addr] + [int(category)] + [int(x) for x in self_id] + [int(x) for x in tele]
     return primary
```

И при сборке `bits` — передать правильный `fs_symbol`:

```diff
-    seq_syms = _build_dsc_frame(primary_symbols, eos_symbol=eos_symbol, include_eos=True)
+    fs_symbol = primary_symbols[0]
+    seq_syms = _build_dsc_frame(primary_symbols[1:], fs_symbol=fs_symbol, eos_symbol=eos_symbol, include_eos=True)
```

5. ## Укладка бит → байты → обратно

Вы делаете «builder → bits → packbits → HEX → generate_dsc_vhf → unpackbits». Это ок, **если** порядок битов внутри байта соблюдён одинаково. По умолчанию `np.packbits`/`np.unpackbits` используют **MSB-first** — это совпадает с тем, что мы хотим (после фикса п.1), так что менять не нужно. Просто убедитесь, что массив `bits` действительно идёт в нужном порядке (MSB-first внутри каждого символа).


