# Спецификация формата AIS (GMSK 9.6 kbps)

**Версия:** 1.1
**Дата:** 2025-10-22
**Назначение:** Детальная спецификация для реализации модулятора/демодулятора AIS

## 1. Основные параметры системы

* **Слот/длительность.** Один слот ≈ **26,67 мс**, в минуте **2250 слотов**; битрейт **9600 бит/с** (256 бит на слот). Используется SOTDMA/ITDMA по ITU-R M.1371. ([ITU][1])
* **Модуляция.** **GMSK**, BT (TX) ≈ **0,4**, индекс модуляции **h = 0,5**. ([cmlmicro.com][2])
* **Каналы.** AIS 1 = **161.975 МГц (87B)**, AIS 2 = **162.025 МГц (88B)**, полоса 25 кГц. ([jeremyclark.ca][3])
* **Частота дискретизации (рекомендуемая).** **⚠️ Fs ДОЛЖНА БЫТЬ КРАТНА 9600 Hz!**
  - **960 кГц** (SPS=100) — ✅ оптимальная для точного декодирования
  - **384 кГц** (SPS=40) — ✅ компактная
  - **192 кГц** (SPS=20) — ✅ минимальная
  - **❌ НЕ используйте 1024 кГц** (SPS=106.67 не целое → ошибки CRC/декодирования)
* **Групповая задержка фильтров.** При демодуляции: ~2.0-2.5 мс (преролл для прогрева фильтров)

## 2. Структура кадра «по воздуху» (после NRZI, перед GMSK)

Структура битов внутри одного слота (HDLC-подобная):

```
┌─────────────┬────────────┬─────────────────────┬────────────┬────────────┬─────────────┐
│  Преамбула  │ Старт-флаг │  Payload + FCS      │  Стоп-флаг │   Буфер    │   Тишина    │
│   24 бита   │   0x7E     │  168+16 бит         │    0x7E    │  24 бита   │  (guard)    │
│  (0101...)  │  (8 бит)   │  (с bit-stuffing!)  │  (8 бит)   │  (любые)   │             │
└─────────────┴────────────┴─────────────────────┴────────────┴────────────┴─────────────┘
     24           8           168+16+N stuffed       8            24           переменная

ИТОГО: минимум 248 бит (без stuffing) → ~256 бит (типично с stuffing) на слот
Длительность слота: 256 бит / 9600 бит/с = 26.67 мс
```

### 2.1. Детали полей

1. **Преамбула (Training sequence)** — **24 бита** чередования `010101010101010101010101` (для захвата синхронизации и восстановления тактовой частоты). **Преамбула НЕ подлежит bit-stuffing.** ([ITU][4])

2. **Старт-флаг** — **8 бит** стандартный HDLC-флаг `0x7E` = `01111110`. ([ITU][4])

3. **Payload (Данные)** — по умолчанию **168 бит** (сообщение в один слот). Более длинные сообщения (Type 5, 12-27 и др.) занимают 2–5 слотов подряд (до 1008 бит). ([ITU][1])

4. **FCS (Frame Check Sequence / CRC)** — **16 бит CRC-16/X25** (HDLC CRC):
   - Полином: **0x8408** (reflected CCITT, `x^16 + x^12 + x^5 + 1`)
   - Инициализация: **0xFFFF**
   - XOR out: **0xFFFF**
   - CRC считается **только по полю Payload** (до NRZI и до bit-stuffing!)
   - Порядок байтов в FCS: **LSB-first** (младший байт первым)
   - **ВАЖНО:** В эфире биты идут LSB-first внутри каждого байта

5. **Стоп-флаг** — **8 бит** `0x7E` (идентичен старт-флагу). ([ITU][4])

6. **Буфер (Guard time)** — **24 бита** (для компенсации джиттера и задержек по дальности). Может быть заполнен нулями или случайными битами. ([ITU][4])

### 2.2. Bit-stuffing (HDLC)

> **Правило**: Внутри поля **Payload + FCS** (между старт-флагом и стоп-флагом) передатчик **вставляет 0** после любой последовательности из **пяти 1** подряд, чтобы избежать ложного флага `0x7E`. При приёме приёмник **удаляет** этот stuffed-бит. ([potaroo.net][5])

**Флаги (0x7E) и преамбула НЕ подвергаются bit-stuffing!**

**Пример stuffing:**
```
Исходные биты payload: ...0111110101...
После stuffing:        ...01111[0]0101...  (вставлен 0 после пяти 1)
                                ^
                              stuffed
```

### 2.3. NRZI-кодирование

> **Правило**: Весь поток битов (включая преамбулу, флаги, stuffed-данные, буфер) **кодируется NRZI** перед подачей на GMSK-модулятор. ([core.ac.uk][6])

**NRZI (Non-Return-to-Zero Inverted):**
- **Бит 0** → **переход уровня** (от −1 к +1 или от +1 к −1)
- **Бит 1** → **нет перехода** (уровень остаётся прежним)

**Пример NRZI:**
```
Биты (после stuffing):  0  1  1  1  1  1  1  0
NRZI-уровни:           +1 -1 -1 -1 -1 -1 -1 +1
                        ↓  =  =  =  =  =  =  ↓
                       (переход)          (переход)
```

**ВАЖНО:** Преамбула `010101...` после NRZI превращается в постоянные переходы (меандр), что идеально для синхронизации PLL приёмника.

## 3. GMSK модуляция

**GMSK (Gaussian Minimum Shift Keying)** — разновидность FSK с предварительной гауссовой фильтрацией, обеспечивающая компактный спектр и постоянную огибающую (важно для линейных усилителей).

### 3.1. Параметры GMSK для AIS

- **Индекс модуляции:** h = **0.5** (минимальный FSK)
- **BT (bandwidth-time product):** **0.4** (TX), **0.3-0.5** (RX)
- **Частотный девиация:** Δf = h × Rs / 2 = 0.5 × 9600 / 2 = **2400 Гц**
- **Полоса (−3 dB):** ~**25 кГц** (соответствует каналу AIS)

### 3.2. Процесс модуляции GMSK

1. **Вход:** Битовый поток после NRZI (±1 символы)
2. **Преобразование в частотные символы:**
   - Бит +1 (NRZI) → символ **−1** (отклонение частоты **−Δf**)
   - Бит −1 (NRZI) → символ **+1** (отклонение частоты **+Δf**)

3. **Гауссов фильтр:**
   - Входной битовый поток фильтруется гауссовым LPF с BT=0.4
   - Ядро фильтра: h[t] = exp(−0.5 × (t / σ)²), где σ ≈ Ts × BT / (π × √(2 × ln(2)))
   - Длина фильтра: ~**4-6 символов** (компромисс между ISI и групповой задержкой)

4. **Фазовая интеграция:**
   - Фазовый накопитель: φ[n] = φ[n−1] + π × h × filtered_symbols[n]
   - Где h=0.5, поэтому Δφ = π/2 на символ (±2400 Гц девиация)

5. **Комплексный сигнал:**
   - I/Q output: s[n] = exp(j × φ[n])
   - Амплитуда константа (envelope = 1.0)

### 3.3. Частотная характеристика

```
   Мощность
      ↑
      │         ╱‾‾‾╲
      │        ╱     ╲
      │       ╱       ╲
      │______╱_________╲________
      │ −25 kHz    0    +25 kHz  → Частота
      │           ^
      │         Fcarrier (161.975 / 162.025 МГц)
```

## 4. Структура Payload (примеры типов сообщений)

### 4.1. Формат payload (общая структура)

Payload всегда начинается с **6-битного Message Type ID**, затем 2-битный **Repeat Indicator**, затем **30-битный MMSI**, далее — зависит от типа.

**Биты нумеруются от старшего (MSB) к младшему (LSB):**
```
Бит 0 (MSB) ────────────────────────────────────────► Бит 167 (LSB)
[Type:6][Rpt:2][MMSI:30][...остальные поля по спецификации...]
```

**ВАЖНО:** В эфире биты передаются **LSB-first внутри каждого байта**! Это означает:
- Байт 0x7E (01111110) передаётся как: 0→1→1→1→1→1→1→0
- Демодулятор получает биты в обратном порядке внутри байта

### 4.2. Типичные типы сообщений (168 бит)

#### Type 1/2/3: Position Report Class A (168 бит)

```
Позиция 0-5    (6):  Message Type (1, 2, или 3)
Позиция 6-7    (2):  Repeat Indicator
Позиция 8-37  (30):  MMSI
Позиция 38-41  (4):  Navigation Status
Позиция 42-49  (8):  Rate of Turn (ROT)
Позиция 50-59 (10):  Speed Over Ground (SOG)
Позиция 60     (1):  Position Accuracy
Позиция 61-88 (28):  Longitude (1/600000 градуса)
Позиция 89-115(27):  Latitude (1/600000 градуса)
Позиция 116-127(12): Course Over Ground (COG)
Позиция 128-136(9):  True Heading
Позиция 137-142(6):  Time Stamp (секунды UTC)
Позиция 143-144(2):  Maneuver Indicator
Позиция 145-147(3):  Spare
Позиция 148    (1):  RAIM flag
Позиция 149-167(19): Radio status
```

#### Type 18: Standard Class B Position Report (168 бит)

```
Позиция 0-5    (6):  Message Type (18)
Позиция 6-7    (2):  Repeat Indicator
Позиция 8-37  (30):  MMSI
Позиция 38-45  (8):  Reserved
Позиция 46-55 (10):  Speed Over Ground
Позиция 56     (1):  Position Accuracy
Позиция 57-84 (28):  Longitude
Позиция 85-111(27):  Latitude
Позиция 112-123(12): Course Over Ground
Позиция 124-132(9):  True Heading
Позиция 133-138(6):  Time Stamp
Позиция 139-140(2):  Regional reserved
Позиция 141    (1):  CS Unit
Позиция 142    (1):  Display flag
Позиция 143    (1):  DSC flag
Позиция 144    (1):  Band flag
Позиция 145    (1):  Msg22 flag
Позиция 146    (1):  Assigned mode
Позиция 147    (1):  RAIM flag
Позиция 148    (1):  Radio status (SOTDMA/ITDMA)
Позиция 149-167(19): Communication state
```

### 4.3. Порядок байтов и битов в HEX

**Контракт демодулятора (`ais_demod.py`):**
- Выход: `payload_hex_msb` — HEX-строка payload **без FCS**, готовая для парсера
- Формат: **big-endian** (старший байт первым), биты собраны **LSB-first** внутри байта (согласно HDLC)

**Пример:**
```
Эфирный поток (после NRZI decode, после destuff):
Биты: 0 0 0 1 0 1 | 0 1 0 0 0 0 0 0 | ... (Type=18, Repeat=0, MMSI начало)
        ↑ Type=18 (binary: 010010, но LSB-first!)
Байт 0: LSB-first → 0x48 (01001000 reversed = 00010010)
Байт 1: LSB-first → 0x1D (00011101 reversed = 10111000)
...

Результат payload_hex_msb: "481d6f34..." (ready для парсера)
```

## 5. Пайплайн модулятора (HEX to CF32)

### 5.1. Архитектура модулятора

```
┌─────────────┐     ┌──────────────┐     ┌───────────┐     ┌───────────┐     ┌──────────┐
│  AIS Payload│────>│  CRC-16/X25  │────>│    Bit    │────>│   NRZI    │────>│   GMSK   │
│   (HEX)     │     │  Append FCS  │     │  Stuffing │     │  Encoding │     │ Modulator│
└─────────────┘     └──────────────┘     └───────────┘     └───────────┘     └──────────┘
     168 бит              184 бит          184+N бит         184+N бит         Complex IQ
                       (payload+FCS)      (stuffed)          (NRZI)            (CF32)
                                                                                    │
                                                                                    v
┌────────────────────────────────────────────────────────────────────────────────────┐
│ Добавить преамбулу (24 бита 0101...) + флаг 0x7E + stuffed frame + флаг 0x7E +    │
│ буфер (24 бита) → NRZI encode all → Gaussian filter (BT=0.4) → Phase modulation   │
│ → Upconvert to RF (161.975 / 162.025 МГц) → CF32 file                             │
└────────────────────────────────────────────────────────────────────────────────────┘
```

### 5.2. Детальный алгоритм модулятора

**Вход:** HEX-строка payload (21 байт = 168 бит для Type 1/18)

**Шаги:**

1. **Парсинг HEX в биты (LSB-first):**
   ```python
   payload_bytes = bytes.fromhex(payload_hex)
   bits = []
   for byte in payload_bytes:
       for i in range(8):
           bits.append((byte >> i) & 1)  # LSB-first
   ```

2. **Вычисление CRC-16/X25:**
   ```python
   def crc16_x25(data: bytes) -> int:
       crc = 0xFFFF
       for b in data:
           crc ^= b
           for _ in range(8):
               if crc & 1:
                   crc = (crc >> 1) ^ 0x8408
               else:
                   crc >>= 1
       crc ^= 0xFFFF
       return crc & 0xFFFF

   fcs = crc16_x25(payload_bytes)
   fcs_bytes = fcs.to_bytes(2, 'little')  # LSB-first
   # Добавить FCS биты (LSB-first):
   for byte in fcs_bytes:
       for i in range(8):
           bits.append((byte >> i) & 1)
   ```

3. **Bit-stuffing:**
   ```python
   stuffed = []
   ones_count = 0
   for bit in bits:  # bits = payload + FCS
       stuffed.append(bit)
       if bit == 1:
           ones_count += 1
           if ones_count == 5:
               stuffed.append(0)  # Вставить 0 после 5 единиц
               ones_count = 0
       else:
           ones_count = 0
   ```

4. **Сборка кадра:**
   ```python
   frame = []
   # Преамбула (24 бита 0101...)
   frame.extend([0, 1] * 12)
   # Старт-флаг 0x7E = 01111110
   frame.extend([0, 1, 1, 1, 1, 1, 1, 0])
   # Stuffed payload + FCS
   frame.extend(stuffed)
   # Стоп-флаг 0x7E
   frame.extend([0, 1, 1, 1, 1, 1, 1, 0])
   # Буфер (24 бита нулей)
   frame.extend([0] * 24)
   ```

5. **NRZI кодирование:**
   ```python
   nrzi_symbols = []
   level = 1  # Начальное состояние
   for bit in frame:
       if bit == 0:
           level = -level  # Переход
       # else: level не меняется
       nrzi_symbols.append(level)
   ```

6. **GMSK модуляция:**
   ```python
   import numpy as np

   # Параметры
   Fs = 1_024_000  # Частота дискретизации
   Rs = 9600       # Symbol rate
   BT = 0.4        # Bandwidth-time product
   h = 0.5         # Modulation index
   SPS = int(Fs / Rs)  # Samples per symbol

   # Передискретизация символов (upsample)
   symbols_up = np.repeat(nrzi_symbols, SPS)

   # Гауссов фильтр
   span = 6  # symbols
   taps = span * SPS
   t = np.arange(-taps//2, taps//2) / Fs
   Ts = 1.0 / Rs
   sigma = Ts * BT / (np.pi * np.sqrt(2 * np.log(2)))
   gauss_h = np.exp(-0.5 * (t / sigma)**2)
   gauss_h /= gauss_h.sum()

   # Фильтрация
   filtered = np.convolve(symbols_up, gauss_h, mode='same')

   # Фазовая модуляция
   phase = np.cumsum(np.pi * h * filtered)

   # Комплексный сигнал (baseband)
   iq = np.exp(1j * phase).astype(np.complex64)

   # Upconvert to RF (опционально, для файла можно оставить baseband)
   # fc = 161_975_000 или 162_025_000
   # t_samples = np.arange(len(iq)) / Fs
   # iq_rf = iq * np.exp(2j * np.pi * fc * t_samples)

   # Сохранить в CF32
   iq.tofile('ais_modulated.cf32')
   ```

## 6. Чек-лист модуляции (HEX → CF32)

### 6.1. Подготовка данных

1. **Сформировать payload** (HEX-строка):
   - Для Type 1/2/3/18: **21 байт** (168 бит)
   - Для других типов: согласно ITU-R M.1371
   - Структура: [Type:6][Repeat:2][MMSI:30][...поля...]
   - Биты упакованы **LSB-first** внутри каждого байта

2. **Вычислить CRC-16/X25:**
   - Алгоритм: reflected CCITT (poly=0x8408, init=0xFFFF, xorout=0xFFFF)
   - Вход: payload байты (НЕ биты!)
   - Выход: 16-битное значение → 2 байта **little-endian**
   - Пример: `crc16_x25(payload_bytes) → fcs_bytes (2 байта)`

3. **Конвертировать payload+FCS в биты (LSB-first):**
   - Для каждого байта: извлечь биты от младшего к старшему
   - Результат: массив битов (168 + 16 = 184 бита)

### 6.2. Фреймирование и кодирование

4. **Применить bit-stuffing:**
   - К битам payload+FCS (НЕ к преамбуле и флагам!)
   - Правило: после 5 подряд идущих «1» вставить «0»
   - Результат: 184 + N битов (N зависит от содержимого)

5. **Собрать полный кадр:**
   ```
   [Преамбула:24] + [Флаг:8] + [Stuffed:184+N] + [Флаг:8] + [Буфер:24]
   ```
   - Преамбула: `010101010101010101010101` (24 бита)
   - Флаг: `01111110` (0x7E)
   - Буфер: 24 бита нулей (или случайные)

6. **NRZI-кодирование всего кадра:**
   - Начальное состояние: `level = +1`
   - Для каждого бита:
     - Бит=0 → инверсия уровня (`level = -level`)
     - Бит=1 → уровень не меняется
   - Результат: массив символов {−1, +1}

### 6.3. GMSK модуляция

7. **Передискретизация (upsampling):**
   - SPS (samples per symbol) = Fs / Rs
   - ⚠️ **SPS ДОЛЖЕН БЫТЬ ЦЕЛЫМ ЧИСЛОМ!** Иначе возникают ошибки CRC/декодирования
   - Пример: Fs=960e3, Rs=9600 → SPS=100 ✅
   - Каждый символ повторить SPS раз

8. **Гауссова фильтрация:**
   - BT = 0.4
   - Длина фильтра: 4-6 символов (span × SPS taps)
   - Формула ядра: `h[t] = exp(−0.5 × (t/σ)²)`, где `σ = Ts × BT / (π × √(2ln2))`
   - Нормировка: `h /= sum(h)`
   - Применить convolution (mode='same')

9. **Фазовая модуляция:**
   - Накопление фазы: `φ[n] = φ[n−1] + π × h × filtered[n]`
   - h = 0.5 (индекс модуляции)
   - Комплексный сигнал: `I+jQ = exp(j × φ[n])`

10. **Сохранить CF32:**
    - Формат: complex64 (numpy dtype), little-endian
    - Структура: `[I0, Q0, I1, Q1, ...]` (чередование float32)
    - Опционально: добавить тишину (нули) в начало/конец для охраны

### 6.4. Проверка качества

11. **Валидация модулированного сигнала:**
    - Проверить спектр: должен быть симметричен относительно 0 Гц (baseband)
    - Полоса по −3 dB: ~25 kHz
    - Огибающая постоянна (GMSK — constant envelope)
    - Демодулировать обратно и сравнить с исходным HEX

## 7. Тестовый пример (эталонный HEX)

### 7.1. Известный payload

**Из задания 2025-10-17 (`AIS_GMSK_plot.py`):**
```
HEX_EXPECTED = "481d6f345403ff33c8d603412140e10fff844e0006"
```

**Расшифровка (Type 18, Class B Position Report):**
- Длина: 21 байт = 168 бит
- Type: 18 (Class B position report)
- MMSI: можно декодировать через `ais_hex_parser.py`

**Использование для тестирования модулятора:**
1. Взять этот HEX как payload (БЕЗ FCS!)
2. Пропустить через модулятор → получить CF32
3. Пропустить CF32 через демодулятор (`ais_demod.py`)
4. Сравнить `payload_hex_msb` с исходным HEX
5. Проверить `crc_valid == True`

## 8. Связь с NMEA/IEC (текстовые «!AIVDM/!AIVDO»)

Формат **NMEA AIVDM/AIVDO** — это **транспорт на последовательном порту** (IEC 61162/NMEA-0183) и **НЕ равен эфиру**:

- Полезная нагрузка упакована в **6-битные ASCII символы** (armored encoding)
- **Checksum `*hh`** — это XOR строки NMEA, **не** эфирный CRC-16
- Для конвертации NMEA ↔ HEX используйте `ais_nmea.py` (если доступен)

**Пример NMEA:**
```
!AIVDM,1,1,,B,H3m>N0pU@PDP00000000000,2*75
```

**Не путать с эфирным форматом!** Для модулятора используйте **payload HEX** (из демодулятора или парсера), не NMEA-строки.

## 9. Рекомендации по реализации модулятора

### 9.1. Архитектура кода

**Рекомендуемая структура:**
```
beacon406/tools/
├── ais_modulator.py          # Основной модулятор (HEX → CF32)
├── ais_payload_builder.py    # Генератор payload по типам сообщений
└── ais_test_vectors.py       # Тестовые векторы (известные HEX + ожидаемые CF32)
```

**Зависимости от существующего кода:**
- `beacon406.lib.ais_demod.crc16_x25()` — для CRC (можно переиспользовать)
- `numpy` — для обработки сигналов
- `scipy.signal` (опционально) — для более точных фильтров

### 9.2. Параметры по умолчанию

```python
# Рекомендуемые константы для модулятора
FS_DEFAULT = 1_024_000  # Частота дискретизации (Hz)
RS_AIS = 9600           # Symbol rate (baud)
BT_TX = 0.4             # Gaussian BT для TX
H_GMSK = 0.5            # Modulation index
PREAMBLE_BITS = 24      # Преамбула (010101...)
GUARD_BITS = 24         # Буфер после стоп-флага
HDLC_FLAG = 0x7E        # Старт/стоп флаг

# Для демодулятора (обратная связь)
BT_RX = 0.4             # Gaussian BT для RX (может быть 0.3-0.5)
TIMING_TRIALS = 16      # Количество попыток восстановления тайминга
PRE_ROLL_MS = 2.4       # Преролл для прогрева фильтров (мс)
```

### 9.3. Советы по отладке

1. **Визуализация спектра:**
   - После модуляции: проверить FFT → должен быть симметричный спектр ±12.5 kHz
   - Использовать `matplotlib` или `AIS_GMSK_plot.py` для просмотра

2. **Проверка NRZI:**
   - Преамбула `010101...` → после NRZI должна быть меандр (постоянные переходы)
   - Флаг 0x7E → после NRZI имеет длинную серию одного уровня (6 бит без перехода)

3. **Валидация bit-stuffing:**
   - Сгенерировать payload с длинными сериями «1» (например, `0xFF...`)
   - Проверить, что stuffed-биты вставлены корректно
   - После демодуляции payload должен совпадать с исходным

4. **Круговое тестирование (round-trip):**
   ```
   HEX → Modulate → CF32 → Demodulate → HEX'
   assert HEX == HEX'
   assert CRC_valid == True
   ```

## 10. Дополнительные ссылки и стандарты

### 10.1. Официальные стандарты

- **ITU-R M.1371-5** (2014): Основной стандарт AIS (Technical characteristics) [↗][1]
- **IEC 61162-1** (NMEA 0183): Интерфейс последовательного порта
- **ISO/IEC 13239**: HDLC procedures (для CRC-16 и bit-stuffing)

### 10.2. Полезные ресурсы

- **USCG NAVCEN AIS Messages**: Справочник по типам сообщений [↗][7]
- **GPSD AIVDM/AIVDO Protocol**: Детали NMEA-формата [↗][8]
- **Jeremy Clark AIS Modulator**: Пример модулятора (Scicos) [↗][3]
- **CML CMX7341 Datasheet**: Детали GMSK параметров [↗][2]

### 10.3. Реализации (для справки)

- **GNU Radio gr-ais**: Open-source демодулятор AIS
- **rtl-ais**: Демодулятор для RTL-SDR
- **Этот проект (`beacon406/lib/ais_demod.py`)**: Эталонная реализация демодулятора

---

## История изменений

| Версия | Дата       | Изменения                                                   |
|--------|------------|-------------------------------------------------------------|
| 1.0    | 2025-10-16 | Первоначальная версия (краткий чек-лист)                    |
| 1.1    | 2025-10-22 | Расширенная спецификация для модулятора (детали GMSK, NRZI, payload, примеры кода) |

---


[1]: https://www.itu.int/dms_pubrec/itu-r/rec/m/R-REC-M.1371-5-201402-I%21%21PDF-E.pdf?utm_source=chatgpt.com "R-REC-M.1371-5-201402-I!!PDF-E.pdf"
[2]: https://cmlmicro.com/Content/Downloads/CMX7341_FI-6_ds.pdf?utm_source=chatgpt.com "CMX7341 Marine Common Platform Processor"
[3]: https://jeremyclark.ca/wp/nav/ais-modulator-scicos-simulation/?utm_source=chatgpt.com "AIS GMSK Modulator – Scicos Simulation - Jeremy Clark"
[4]: https://www.itu.int/dms_pubrec/itu-r/rec/m/R-REC-M.1371-1-200108-S%21%21PDF-E.pdf?utm_source=chatgpt.com "RECOMMENDATION ITU-R M.1371-1"
[5]: https://www.potaroo.net/ietf/rfc/rfc1549.html?utm_source=chatgpt.com "PPP in HDLC Framing"
[6]: https://core.ac.uk/download/pdf/37321171.pdf?utm_source=chatgpt.com "A Software-Defined Radio Implementation of Maritime AIS"
[7]: https://www.navcen.uscg.gov/ais-messages?utm_source=chatgpt.com "AIS Messages | Navigation Center - USCG Navcen"
[8]: https://gpsd.gitlab.io/gpsd/AIVDM.html?utm_source=chatgpt.com "AIVDM/AIVDO protocol decoding"
